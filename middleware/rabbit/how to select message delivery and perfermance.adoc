== 消息投递速度和消息可靠性的问题
可以从以下几个方面来考虑问题

* 消息发布时保证消息进入队列的重要性高吗？

* 如果消息无法路由，是否应将消息返回给发布者?

* 如果消息无法路由，是否应该将其发送到其他地方稍后进行路由?

* 如果RabbitMQ 服务器崩溃，是否可以接受消息丢失?

* RabbitMQ 在处理信息消息时是否应该确认它已经为发布者执行了所有请求的路由和持久化任务

* 消息发布者是否可以批量投递消息，然后从 RabbitMQ 收到一个确认用于表明所有请求的路由和持久化任务已经批量应用到所有的消息中?

* 如果要批量发布消息，而这些消息需要确认路由和持久化，那么对每一条消息是否需要对目标队列实现真正意义上的原子提交

* 在可靠投递方面是否有可接受的平衡性，发布者可以使用它来实现更高的性能和消息吞吐量吗?

* 消息发布还有哪些方面会影响消息吞吐量和性能?

== 使用 mandatory 参数

* 当在调用 *Channel#basicPublish* 的时候，将 *mandatory* 的flag 设置为 true 时可以实现

* *mandatory* 相当于是故障检测模式，假如消息发布到 *exchange* 的时候不可路由，那么会通过 *Basci.Return* 的命令返回发布者, 发布成功则不会回复

* *Basic.Return* 的调用是异步的, 所以在大多数库的实现中，需要实现添加对 *Basic.Return* 的监听器才能监听到失败的消息

== 使用 Producer ACK

* *AMQP* 规范的增强功能

* 生产者调用 *Confirm.Select*， 并等待 *Confirm.SelectOk* 响应

* 开启后，对于生产者发送的每一条消息 服务器都会回复 *Basic.ACk* 或者 *Basic.NACK* 消息来告知消息是否投递成功或无法路由

* 当生产者发布给所有队列的已路由消息被消费者应用程序直接消费时，或者消息被放入队列并根据需要进行持久化时, 会回复 *Basic.ACK* 消息

* 当消息无法路由时，会回复 *Basic.NACK* 消息

* *Producer ACK* 不会和 事务相关的功能一起使用

* *Basic.ACK* 和 *Basic.NACK* 的响应也是异步的

== 使用备用交换器处理无法路由的消息

* RabbitMQ 创建的 AMQ 模型的另一个拓展

* 在声明 *Exchange* 的时候可以指定备份交换器，使用 *alternate-exchange* 属性来指定备用交换器，备用交换器需要先被声明

* 备用交换器也需要当作普通的交换器一样声明，并且绑定队列才能使用

* 当消息不可路由且 *mandatory* 参数设置的情况下，消息会被送往备份交换器，而不会通过 *Basic.Return* 返回生产者

== 基于事务的批量处理

* 生产者调用 *TX.Select* 后，服务端回复 *Tx.SelectOK*, 之后生产者可以发布多条消息

* 生产者调用 *Tx.Commit* 进行提交, 服务端发布完全部消息后回复 *Tx.CommitOK*。假如消息无法路由，那么服务器会发送 *Basic.Return* 消息，生产者可以决定是否要调用 *Tx.Rollback*

* 生产者调用 *Tx.Rollback* 进行回滚

* 只有在发布的消息只投递到一个队列时，事务的提交才具有原子性,但是通常生产者难以确认这一点

* 在使用 HA 队列时，需要确保所有的节点都收到消息后才会发送 *Tx.CommitOK*

* 如果只是需要 消息投递的确认的话，那么使用生产者确认是更好的

== 使用 HA 队列

* 非 AMQP 规范, 需要集群模式的 RabbitMQ

* 在 *Queue.Declare* 的时候，传入 *x-ha-policy* 来指定消息应该发布到多少节点.

** 使用 *all* 的时候消息会被发布到集群中的每个节点

** 使用 *nodes* 的时候需要再次声明一个参数 *x-ha-nodes*, 参数值就是节点名称

* HA队列有一个主服务器节点，其他所有节点都是辅助节点。

** 如果主节点发生故障，那么其中一个辅助节点将接管主节点的角色

** 如果一个辅助节点宕机了，其他节点将正常运行

** 当宕机的节点回复或者一个新的节点被加入集群时，不会同步之前的数据

* 当消息在集群中的任何节点完成消费时，消息的所有副本都会立即从其他节点上删除

== 持久化发布数据

* 将队列申明为 *durable* 将 *delivery-mode* 设置为2， RabbitMQ 将确保消息保存到磁盘，这样服务器重启的时候，消息就不会丢失

* RabbitMQ 一次存储一个持久化消息，并追踪其在每个队列中的引用，一旦引用全部消失，就从磁盘上删除