== 如何使用 Redis 来完成各种统计类的需求

=== 如何完成聚合统计

指的是多个集合元素的聚合结果，一般有: *交集*， *并集*， *补集* 等操作

eg: 比如需要统计某个手机APP每天的新增用户数和第二天的留存用户数

* 使用一个 set 记录 所有登录过 APP 的用户ID, 之后将每天登录的用户的ID 记录到另外的集合中去

* 之后就可以使用 *SUNIONSTORE* 统计累计用户集合和每天新增的用户集合之间的差集来计算新增用户数量

* Set 的差集，并集和交集的计算复杂度比较高，在数据量较大的情况下，不建议直接执行这些计算，建议用从库来执行，或者干脆不用这种方案

* 多个集群之间无法对多个 key 进行聚合计算

TIP: 感觉在数据库里根据 *create_time* 查询, 或者记录 用户注册的事件 的方式会更方便

=== 排序统计

要求集合不但能对元素进行存储，也要能进行排序

* *list* 类型是按照元素进入的顺序进行排序

* *zset* 类型是按照元素的权重进行排序

eg: 比如需要展示最新列表，排行榜等场景

TIP: 这种需要频繁更新或者分页显示的场景，使用 *zset* 的话每页的数据是固定的，不像 *list* 的元素会逐步后移, 可以考虑下两个集合的特点


=== 二值状态统计

二值指的是集合元素的取值只有 0 和 1,典型的比如签到打卡

对于这种类型，可以使用 Redis 的拓展类型 *bitmap*

TIP: Bitmap本身是用String类型作为底层数据结构实现的一种统计二值状态的数据类型。String类型是会保存为二进制的字节数组，所以，Redis就把字节数组的每个bit位利用起来，用来表示一个元素的二值状态。可以把Bitmap看作是一个bit数组

* 可以设置bit位

* 可以get bit 位

* 可以统计某个bitmap上的 1 的个数

* 可以对多个 bitmap 做 按位 *与* *或* *异或* 等操作

=== 基数统计

统计一个集合中不重复的人员个数

比如统计某个站点的 uv

* 可以使用 *Set* 集合

* 也可以使用 *Hash* 集合, 将用户id设置位 *key*

TIP: 上述两个集合在需要统计的页面很多时，会消耗非常大的内存空间

* 统计基数特别大的时候，可以考虑使用 *HyperLogLog* 这种数据类型集合

* 其最大的优势在于，当集合的元素数量非常多的时候，它计算基数所需的空间是固定的，而且不大

* 大概只需要 12kb 的内存，就可以统计 2 ^ 64 个元素的基数

* 统计结果有一定的误差，大概在 0.81% 左右

TIP: 真正生产环境的大数据量统计需求，可能都是流系统来做的