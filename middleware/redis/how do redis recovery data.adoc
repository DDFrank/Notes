== Redis恢复数据的重要性

* Redis 主要用作缓存，但是一旦宕机， 内存中的数据将全部丢失

* 从数据库恢复数据的话，会造成短时访问数据库的流量激增，可能造成数据库压力过大

* 所以及时redis宕机了，恢复的时候也要尽可能的恢复数据

* Redis 恢复的数据的两大手段: AOF日志 和 RDB快照

== AOF日志

=== AOF 是如何实现的

* Redis 先执行命令，再去写日志

* Redis 记录日志的时候不会去检查命令的语法错误，所以只写能成功执行命令的日志的话，可以避免记录错误的指令

* 执行命令后再去写日志，就不会阻塞当前的写操作

=== AOF 的潜在风险

* 假如刚执行完命令，还没来得及写日志就挂了，那么这个数据就无法恢复了

* 可能会阻塞下一个写指令

* 这些风险都跟 AOF 何时落盘有关，所以 Redis 提供了三种 写回磁盘的策略

=== AOF 的写回策略

* *Always*，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；

* *Everysec*，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；

* *No*，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘

IMPORTANT: AOF 是以文件的形式记录日志的，当AOF的文件过大时，效率就会降低，比如系统本身对文件大小有限制，追加记录时性能下降，恢复时过慢

=== AOF 重写 

* 为了避免 AOF 文件增长的过慢, 采用了 AOF 重写机制

* 重写的主要就是根据 数据库键值的最新情况，会根据每个key 生成最新的命令，记录在日志中

==== AOF 重写实现

* 重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降

* 重写发生时，父进程会 fork 一个 bgrewriteaof 子进程，这样，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写出操作日志

IMPORTANT: Linux fork 的时候默认是 *copy on write* 的，因此不会真的把整个内存拷贝一份

* 此时主线程并未阻塞，仍然可以处理新的请求，如果有写操作，那么日志仍回写到 AOF 日志的缓冲区中，即使宕机了还是可以用这个文件来恢复

* 主线程的写操作还会被写到重写日志的缓冲区去,这样重写日志也不会丢失最新的操作。等到重写完成后，重写日志的缓冲区中的日志就直接追加到末尾，此时就可以直接用新的AOF文件替代旧文件即可

==== AOF重写触发的时机

* 手动执行 bgrewriteaof 触发 AOF 重写

* redis.conf 文件中有注明重写发生的条件
auto-aof-rewrite-min-size 64MB // 当文件小于64M时不进行重写
auto-aof-rewrite-min-percenrage 100 // 当文件比上次重写后的文件大100%时进行重写

== RDB 数据快照

IMPORTANT: 使用 AOF 恢复数据的时候，因为是操作日志，所以假如日志的数量非常多，那么恢复就会变得十分缓慢， 使用RDB恢复就会快很多

=== 数据快照的范围

* Redis 的数据快照是全量备份， 所以进行备份的时候，可能因为数据量比较大，导致写入操作耗时

* Redis 提供了两个命令来生成 RDB 文件

** save: 在主线程中执行，会阻塞正常的读写操作

** bgsave: 默认值。会 fork 一个子进程, 专门用于写入 RDB 文件， 避免阻塞

=== 数据快照时，主线程是否可以修改数据

* Redis 会借助 操作系统提供的 写时复制(Copy-On-Write, COW) 技术,在执行快照的时候，正常处理写操作

** bgsave子进程是由主线程fork生成的，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把它们写入RDB文件

** 如果主线程对这些数据也都是读操作，那么，主线程和bgsave子进程相互不影响

** 如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave子进程会把这个副本数据写入RDB文件，而在这个过程中，主线程仍然可以直接修改原来的数据


=== 数据快照的频率

* 快照的频率过大，会增大数据丢失的风险

* 频繁的执行全量备份的快照，也会带来性能开销

** 频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环

** bgsave子进程需要通过fork操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁fork出bgsave子进程，这就会频繁阻塞主线程了

== AOF 和 RDB 混合

* 内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作

* 快照不用很频繁地执行，这就避免了频繁fork对主线程的影响

* AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销

* 比较好的方式
