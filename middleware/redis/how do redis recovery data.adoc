== Redis恢复数据的重要性

* Redis 主要用作缓存，但是一旦宕机， 内存中的数据将全部丢失

* 从数据库恢复数据的话，会造成短时访问数据库的流量激增，可能造成数据库压力过大

* 所以及时redis宕机了，恢复的时候也要尽可能的恢复数据

* Redis 恢复的数据的两大手段: AOF日志 和 RDB快照

== AOF日志

=== AOF 是如何实现的

* Redis 先执行命令，再去写日志

* Redis 记录日志的时候不会去检查命令的语法错误，所以只写能成功执行命令的日志的话，可以避免记录错误的指令

* 执行命令后再去写日志，就不会阻塞当前的写操作

=== AOF 的潜在风险

* 假如刚执行完命令，还没来得及写日志就挂了，那么这个数据就无法恢复了

* 可能会阻塞下一个写指令

* 这些风险都跟 AOF 何时落盘有关，所以 Redis 提供了三种 写回磁盘的策略

=== AOF 的写回策略

* *Always*，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；

* *Everysec*，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；

* *No*，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘

IMPORTANT: AOF 是以文件的形式记录日志的，当AOF的文件过大时，效率就会降低，比如系统本身对文件大小有限制，追加记录时性能下降，恢复时过慢

=== AOF 重写 

* 为了避免 AOF 文件增长的过慢, 采用了 AOF 重写机制

* 重写的主要就是根据 数据库键值的最新情况，会根据每个key 生成最新的命令，记录在日志中

==== AOF 重写实现

* 重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降

* 重写发生时，父进程会 fork 一个 bgrewriteaof 子进程，这样，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写出操作日志

IMPORTANT: Linux fork 的时候默认是 *copy on write* 的，因此不会真的把整个内存拷贝一份

* 此时主线程并未阻塞，仍然可以处理新的请求，如果有写操作，那么日志仍回写到 AOF 日志的缓冲区中，即使宕机了还是可以用这个文件来恢复

* 主线程的写操作还会被写到重写日志的缓冲区去,这样重写日志也不会丢失最新的操作。等到重写完成后，重写日志的缓冲区中的日志就直接追加到末尾，此时就可以直接用新的AOF文件替代旧文件即可

==== AOF重写触发的时机

* 手动执行 bgrewriteaof 触发 AOF 重写

* redis.conf 文件中有注明重写发生的条件
auto-aof-rewrite-min-size 64MB // 当文件小于64M时不进行重写
auto-aof-rewrite-min-percenrage 100 // 当文件比上次重写后的文件大100%时进行重写
