== Redis 的缓存淘汰策略
4.0 之前有6种，4.0 之后又增加了2种

=== 不会淘汰数据的策略

* noeviction

Redis在使用的内存空间超过maxmemory值时，并不会淘汰数据，也就是设定的noeviction策略。对应到Redis缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis不再提供服务，而是直接返回错误

=== 在设置了过期时间的数据中进行淘汰

TIP: 无论是设置了 EXPIRE 的键值对的过期时间是快到了，还是Redis的内存使用量达到了 *maxmemory* 阈值，Redis都会进一步按照下面的规则进行淘汰

* volatile-random

在设置了过期时间的键值对中，进行随机删除

* volatile-ttl

针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删

* volatile-lru

使用LRU算法筛选设置了过期时间的键值对

* volatile-lfu (4.0 新增)

使用LFU算法选择设置了过期时间的键值对

=== 在所有的数据范围内进行淘汰

* allkeys-random

从所有键值对中随机选择并删除数据

* allkeys-lru

使用LRU算法在所有数据中进行筛选

* allkeys-lfu (4.0新增)

使用LFU算法在所有数据中进行筛选

=== Redis 的 LRU 算法

TIP: 对 LRU 算法做了简化，避免维护全部数据的链表

* Redis默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构RedisObject中的lru字段记录）

* Redis在决定淘汰的数据时，第一次会随机选出N个数据，把它们作为一个候选集合 (由配置参数 *maxmemory-samples* 控制)

* 接下来，Redis会比较这N个数据的lru字段，把lru字段值最小的数据从缓存中淘汰出去。需要再次淘汰的时候，需要挑选数据进入候选集合

IMPORTANT: 进入淘汰集合的挑选标准是: 能进入候选集合的数据的lru字段值必须小于候选集合中最小的lru值

IMPORTANT: 单纯只使用LRU算法的话，没有办法 在 *扫描式单次查询操作* 时避免缓存污染的问题。因为 *扫描式单次查询* 会把大量数据访问一遍，然后就不访问了，所以这些数据的 lru 值都会很大，就不容易被淘汰。要避免这个问题，可以使用 LFU 策略 

=== 淘汰策略使用建议

* 优先使用allkeys-lru策略。可以充分利用LRU这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果业务数据中有明显的冷热数据区分，建议使用allkeys-lru策略。

* 如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用allkeys-random策略，随机选择淘汰的数据就行

* 如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用volatile-lru策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据LRU规则进行筛选


=== Redis 的 LFU 算法

LFU缓存策略是在LRU策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用LFU策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存

和那些被频繁访问的数据相比，扫描式单次查询的数据因为不会被再次访问，所以它们的访问次数不会再增加。因此，LFU策略会优先把这些访问次数低的数据淘汰出缓存。这样一来，LFU策略就可以避免这些数据对缓存造成污染了

==== Redis是如何实现的

* Redis在实现LFU策略的时候，只是把原来24bit大小的lru字段，拆成了2部分

** ldt值：lru字段的前16bit，表示数据的访问时间戳

** counter值：lru字段的后8bit，表示数据的访问次数

** 当LFU策略筛选数据时，Redis会在候选集合中，根据数据lru字段的后8bit选择访问次数最少的数据进行淘汰。当访问次数相同时，再根据lru字段的前16bit值大小，选择访问时间最久远的数据进行淘汰

==== counter 值是如何增长的

* counter 最大为 255, 假如每访问一次就加1的话，很快就会达到最大值,所以不能采取这种方式

* LFU策略实现的计数规则是：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 *lfu_log_factor* 再加1，再取其倒数，得到一个p值；然后，把这个p值和一个取值范围在（0，1）间的随机数r值比大小，只有p值大于r值时，计数器才加1

[source, c]
----
// 随机值
double r = (double)rand()/RAND_MAX;
...
// bseval是 counter 的值 
double p = 1.0/(baseval*server.lfu_log_factor+1);
if (r < p) counter++;  
----

* *lfu_log_factor* 的值设置的越大， counter 的增长越快，一般设置为10即可


==== counter 的衰减机制

* 在一些场景下，有些数据在短时间内被大量访问后就不会再被访问了。那么再按照访问次数来筛选的话，这些数据会被留存在缓存中，但不会提升缓存命中率。为此，Redis在实现LFU策略时，还设计了一个counter值的衰减机制

* LFU策略使用衰减因子配置项 *lfu_decay_time* 来控制访问次数的衰减。LFU策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，LFU策略再把这个差值除以 *lfu_decay_time* 值，所得的结果就是数据counter要衰减的值

* 所以 *lfu_decay_time* 配置的越小，衰减的越快, 一般设置为1即可

