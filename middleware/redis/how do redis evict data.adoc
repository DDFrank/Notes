== Redis 的缓存淘汰策略
4.0 之前有6种，4.0 之后又增加了2种

=== 不会淘汰数据的策略

* noeviction

Redis在使用的内存空间超过maxmemory值时，并不会淘汰数据，也就是设定的noeviction策略。对应到Redis缓存，也就是指，一旦缓存被写满了，再有写请求来时，Redis不再提供服务，而是直接返回错误

=== 在设置了过期时间的数据中进行淘汰

TIP: 无论是设置了 EXPIRE 的键值对的过期时间是快到了，还是Redis的内存使用量达到了 *maxmemory* 阈值，Redis都会进一步按照下面的规则进行淘汰

* volatile-random

在设置了过期时间的键值对中，进行随机删除

* volatile-ttl

针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删

* volatile-lru

使用LRU算法筛选设置了过期时间的键值对

* volatile-lfu (4.0 新增)

使用LFU算法选择设置了过期时间的键值对

=== 在所有的数据范围内进行淘汰

* allkeys-random

从所有键值对中随机选择并删除数据

* allkeys-lru

使用LRU算法在所有数据中进行筛选

* allkeys-lfu (4.0新增)

使用LFU算法在所有数据中进行筛选

=== Redis 的 LRU 算法

TIP: 对 LRU 算法做了简化，避免维护全部数据的链表

* Redis默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构RedisObject中的lru字段记录）

* Redis在决定淘汰的数据时，第一次会随机选出N个数据，把它们作为一个候选集合 (由配置参数 *maxmemory-samples* 控制)

* 接下来，Redis会比较这N个数据的lru字段，把lru字段值最小的数据从缓存中淘汰出去。需要再次淘汰的时候，需要挑选数据进入候选集合

IMPORTANT: 进入淘汰集合的挑选标准是: 能进入候选集合的数据的lru字段值必须小于候选集合中最小的lru值

=== 淘汰策略使用建议

* 优先使用allkeys-lru策略。可以充分利用LRU这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果业务数据中有明显的冷热数据区分，建议使用allkeys-lru策略。

* 如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用allkeys-random策略，随机选择淘汰的数据就行

* 如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用volatile-lru策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据LRU规则进行筛选




