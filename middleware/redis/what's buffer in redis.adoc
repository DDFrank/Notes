== Redis 的缓冲区

缓冲区就是用来避免请求或数据丢失惨案的, 但是容易出现溢出的问题

* 缓冲区在Redis中的一个主要应用场景，就是在客户端和服务器端之间进行通信时，用来暂存客户端发送的命令数据，或者是服务器端返回给客户端的数据结果

* 缓冲区的另一个主要应用场景，是在主从节点间进行数据同步时，用来暂存主节点接收的写命令和数据

=== 客户端输入和输出缓冲区

* 为了避免客户端和服务器端的请求发送和处理速度不匹配，服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区，称之为客户端输入缓冲区和输出缓冲区

* 输入缓冲区会先把客户端发送过来的命令暂存起来，Redis主线程再从输入缓冲区中读取命令，进行处理。当Redis主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端

==== 什么情况可能导致输入缓冲区溢出

* 写入了bigkey，比如一下子写入了多个百万级别的集合类型数据

* 服务器端处理请求的速度过慢，例如，Redis主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多

==== 如何查看输入缓冲区的内存使用情况

要查看和服务器端相连的每个客户端对输入缓冲区的使用情况，可以使用 *CLIENT LIST* 命令

[source, shell]
----
CLIENT LIST

id=5 addr=127.0.0.1:50487 fd=9 name= age=4 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client
----

* addr 表示一个客户端的情况，如果有多个客户端连接，那么就会显示多个

* 与输入缓冲区相关的参数:

** *cmd*，表示客户端最新执行的命令。这个例子中执行的是CLIENT命令

** *qbuf*，表示输入缓冲区已经使用的大小。这个例子中的CLIENT命令已使用了26字节大小的缓冲区

** qbuf-free，表示输入缓冲区尚未使用的大小。这个例子中的 *CLIENT* 命令还可以使用32742字节的缓冲区。*qbuf* 和 *qbuf-free* 的总和就是，Redis服务器端当前为已连接的这个客户端分配的缓冲区总大小。这个例子中总共分配了 26 + 32742 = 32768字节，也就是32KB的缓冲区

==== 如何应对输入缓冲区溢出

TIP: 可以通过 *CLIENT* 命令来查看, 如果 *qbuf* 很大，而同时 *qbuf-free* 很小，就要引起注意了。客户端输入缓冲区溢出的时候， Redis会把客户端的连接关闭掉

* 把缓冲区调大

没有办法调整客户端输入缓冲区的大小。Redis默认为每个客户端设置的阈值是 *1G*

* 从数据命令的发送和处理速度入手
避免客户端写入bigkey，以及避免Redis主线程阻塞

==== 什么情况可能导致输出缓冲区溢出及如何应对

TIP: Redis为每个客户端设置的输出缓冲区包括两部分：一部分，是一个大小为16KB的固定缓冲空间，用来暂存OK响应和出错信息(大小可预测)；另一部分，是一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果

* 服务器端返回 *bigkey* 的大量结果

* 执行了 *MONITOR* 命令

TIP: MONITOR命令是用来监测Redis执行的。执行这个命令之后，就会持续输出监测到的各个命令操作

MONITOR的输出结果会持续占用输出缓冲区，并越占越多，最后的结果就是发生溢出。所以, MONITOR命令主要用在调试环境中，不要在线上生产环境中持续使用MONITOR (偶尔使用可以)

* 缓冲区大小设置得不合理

** 可以通过 *client-output-buffer-limit* 配置项，来设置缓冲区的大小

** 设置缓冲区大小的上限阈值

** 设置输出缓冲区持续写入数据的数量上限阈值，和持续写入数据的时间的上限阈值

==== 如何设置输出缓冲区的大小

* 对于普通客户端来说

[source, shell]
----
client-output-buffer-limit normal 0 0 0
----

对于普通客户端来说，它每发送完一个请求，会等到请求结果返回后，再发送下一个请求，这种发送方式称为阻塞式发送。在这种情况下，如果不是读取体量特别大的bigkey，服务器端的输出缓冲区一般不会被阻塞的, 所以不需要特别限制

* 对于订阅客户端来说

[source, shell]
----
# 8mb表示输出缓冲区的大小上限为8MB，一旦实际占用的缓冲区大小要超过8MB，服务器端就会直接关闭客户端的连接。
# 2mb和60表示，如果连续60秒内对输出缓冲区的写入量超过2MB的话，服务器端也会关闭客户端连接
client-output-buffer-limit pubsub 8mb 2mb 60
----

对于订阅客户端来说，一旦订阅的Redis频道有消息了，服务器端都会通过输出缓冲区把消息发给客户端。所以，订阅客户端和服务器间的消息发送方式，不属于阻塞式发送。不过，如果频道消息较多的话，也会占用较多的输出缓冲区空间

=== 主从集群间中的缓冲区

TIP: 主从集群间的数据复制包括全量复制和增量复制两种。全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库

==== 复制缓冲区的溢出问题

* 在全量复制过程中，主节点在向从节点传输RDB文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等RDB文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步

* 如果在全量复制时，从节点接收和加载RDB较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出

==== 如何避免复制缓冲区的溢出

* 可以控制主节点保存的数据量大小。按通常的使用经验，主节点的数据量控制在 *2~4GB*，这样可以让全量同步执行得更快些，避免复制缓冲区累积过多命令

* 可以使用 *client-output-buffer-limit* 配置项，来设置合理的复制缓冲区大小。设置的依据，就是主节点的数据量大小、主节点的写负载压力和主节点本身的内存大小

[source, shell]
----
#slave参数表明该配置项是针对复制缓冲区的。512mb代表将缓冲区大小的上限设置为512MB；128mb和60代表的设置是，如果连续60秒内的写入量超过128MB的话，也会触发缓冲区溢出
config set client-output-buffer-limit slave 512mb 128mb 60
----

* 主节点上复制缓冲区的内存开销，会是每个从节点客户端输出缓冲区占用内存的总和。如果集群中的从节点数非常多的话，主节点的内存开销就会非常大。所以，必须得控制和主节点连接的从节点个数，不要使用大规模的主从集群

==== 复制积压缓冲区的溢出问题

* 主节点在把接收到的写命令同步给从节点时，同时会把这些写命令写入复制积压缓冲区。一旦从节点发生网络闪断，再次和主节点恢复连接后，从节点就会从复制积压缓冲区中，读取断连期间主节点接收到的写命令，进而进行增量同步

* 复制积压缓冲区是一个大小有限的环形缓冲区。当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制

* 为了应对复制积压缓冲区的溢出问题，我们调整复制积压缓冲区的大小，也就是设置 *repl_backlog_size* 这个参数的值



