== Redis 并不是完全的单线程模型

* Redis的网络IO和键值对读写是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程

* Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行

== Redis 为什么采用单线程

* 多线程模型面临共享资源的并发控制问题, 这个问题通常是比较复杂的

* 多线程上下文切换存在开销

== Redis 单线程运行为什么那么快

* 所有操作在内存中完成，内存读写本身就比较快

* 采用了高效的数据结构, 执行效率高

* 采用多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率

=== 阻塞线程模型的弊端

* 线程有可能阻塞在 *accept* 或者 *recv* 上， 此时线程其实是空闲的，资源被浪费了

=== socket 的非阻塞模式

* 可以设置 listen() 函数的非阻塞模式，这样 accpet() 就是非阻塞的

* 也可以设置 accpet() 的非阻塞模式，这样 send()/recv() 就是非阻塞的

=== select/poll

* Linux中的IO多路复用机制是指一个线程处理多个IO流，就是select/epoll机制

该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给Redis线程处理，这就实现了一个Redis线程处理多个IO流的效果

* 为了在请求到达时能通知到Redis线程，select/epoll提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数

select/epoll一旦监测到FD上有请求到达时，就会触发相应的事件。

这些事件会被放进一个事件队列，Redis单线程对该事件队列不断进行处理。这样一来，Redis无需一直轮询是否有请求实际发生，这就可以避免造成CPU资源浪费。同时，Redis在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为Redis一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis的响应性能
