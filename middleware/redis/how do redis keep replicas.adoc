== Redis 切片集群

=== 如何保存更多数据

* 纵向拓展

升级单个Redis实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的CPU

** 实施起来方便简单

** 当使用RDB对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程fork子进程时就可能会阻塞

** 纵向扩展会受到硬件和成本的限制

* 横向拓展

横向增加当前Redis实例的个数，原来使用1个8GB内存、50GB磁盘的实例，现在使用三个相同配置的实例

** 数据存储规模很大时，适合使用

=== 数据切片和实例的对应分布关系

* Redis Cluster方案采用哈希槽（Hash Slot），来处理数据和实例之间的映射关系

* 在Redis Cluster方案中，一个切片集群共有16384个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的key，被映射到一个哈希槽

* 首先根据键值对的key，按照CRC16算法计算一个16 bit的值；然后，再用这个16bit值对16384取模，得到0~16383范围内的模数，每个模数代表一个相应编号的哈希槽

* 在部署Redis Cluster方案时，可以使用cluster create命令创建集群，此时，Redis会自动把这些槽平均分布在集群实例上

* 也可以使用cluster meet命令手动建立实例间的连接，形成集群，再使用cluster addslots命令，指定每个实例上的哈希槽个数 (适用于多个实例配置不均匀的情况)

* 在手动分配哈希槽时，需要把16384个槽都分配完，否则Redis集群无法正常工作 (可以通过 addslots {0..5461} 的方式指定范围)

=== 客户端如何定位数据

* Redis实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了

* 客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端

* 客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了

=== 哈希槽和实例对应关系的变化

* 在集群中，实例有新增或删除，Redis需要重新分配哈希槽

* 为了负载均衡，Redis需要把哈希槽在所有实例上重新分布一遍

* 实例之间可以通过相互传递消息，获得最新的哈希槽分配信息

==== 客户端的重定向机制

* 当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的MOVED命令响应结果，这个结果中就包含了新实例的访问地址

[source, shell]
----
GET hello:key
(error) MOVED 13320 172.16.19.5:6379
----

* 客户端收到 move 命令后，也会同步更新本地缓存

==== 槽位数据迁移部分完成的情况

* 当客户端请求时，实例中的数据还没完全迁移完成时

* 客户端就会收到一条ASK报错信息

[source, shell]
----
GET hello:key
(error) ASK 13320 172.16.19.5:6379
----

* 这个结果中的ASK命令就表示，客户端请求的键值对所在的哈希槽13320，在172.16.19.5这个实例上，但是这个哈希槽正在迁移

* 客户端需要先给172.16.19.5这个实例发送一个ASKING命令(让这个实例允许执行客户端接下来发送的命令),然后，客户端再向这个实例发送GET命令，以读取数据

* 和MOVED命令不同，ASK命令并不会更新客户端缓存的哈希槽分配信息


