== 如何避免 Redis 在运行时发生阻塞

=== Redis 实例有哪些对象交互操作

* *客户端* : 网络IO，键值对增删改查操作，数据库操作

* *磁盘* ：生成RDB快照，记录AOF日志，AOF日志重写；

* *主从节点* ：主库生成、传输RDB文件，从库接收RDB文件、清空数据库、加载RDB文件；

* *切片集群实例* ：向其他实例传输哈希槽信息，数据迁移

=== 与客户端交互的时候的阻塞点

* Redis 使用了 IO 多路复用机制，避免了主线程一直处在等待网络连接或请求到来的状态，所以，网络IO不是导致Redis阻塞的因素

* 复杂度高的增删改查操作肯定会阻塞Redis （操作的复杂为O(N)的操作）

** 集合元素全量查询操作HGETALL、SMEMBERS

** 集合的聚合统计操作，例如求交、并和差集

* *bigkey* 集合自身的删除操作

TIP: 删除操作的本质是要释放键值对占用的内存空间。释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序，所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成Redis主线程的阻塞

* 清空数据库( *FLUSHDB* 和 *FLUSHALL* )，因为也是删除大量元素，也会造成阻塞

=== 与磁盘交互时的阻塞点

* Redis设计为采用子进程的方式生成RDB快照文件，以及执行AOF日志重写操作。这样一来，这两个操作由子进程负责执行，慢速的磁盘IO就不会阻塞主线程了

* Redis直接记录AOF日志时，会根据不同的写回策略对数据做落盘保存。一个同步写磁盘的操作的耗时大约是1～2ms，如果有大量的写操作需要记录在AOF日志中，并同步写回的话，就会阻塞主线程了

=== 主从节点交互时的阻塞

* 主从集群中，主库需要生成RDB文件，并传输给从库。主库在复制的过程中，创建和传输RDB文件都是由子进程来完成的，不会阻塞主线程。但是，对于从库来说，它在接收了RDB文件后，需要使用 *FLUSHDB* 命令清空当前数据库, 此时会有阻塞

* 从库在清空当前数据库后，还需要把RDB文件加载到内存，这个过程的快慢和RDB文件的大小密切相关，RDB文件越大，加载过程越慢

=== 切片集群实例交互时的阻塞点

* 部署Redis切片集群时，每个Redis实例上分配的哈希槽信息需要在不同实例间进行传递，同时，当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对Redis主线程的阻塞风险不大

* 如果使用了 *Redis Cluster* 方案，而且同时正好迁移的是 *bigkey* 的话，就会造成主线程的阻塞，因为 *Redis Cluster* 使用了 *同步迁移*

=== 如何避免阻塞点

* 读操作是典型的*关键路径操作*，因为客户端发送了读操作之后，就会等待读取的数据返回，以便进行后续的数据处理。而 *集合全量查询和聚合操作* 都涉及到了读操作，所以，它们是不能进行异步操作了

* *bigkey删除* 和 *清空数据库* 不是关键路径操作，因此可以使用后台子线程来进行异步操作

* *AOF日志同步写* 来说，为了保证数据可靠性，Redis实例需要保证AOF日志中的操作记录已经落盘，这个操作虽然需要实例等待，但它并不会返回具体的数据结果给实例。所以也可以启动一个子线程来执行AOF日志的同步写，而不用让主线程等待AOF日志的写完成

* *从库加载RDB文件* 这个阻塞点。从库要想对客户端提供数据存取服务，就必须把RDB文件加载完成。所以，这个操作也属于关键路径上的操作，所以必须让从库的主线程来执行

=== Redis 的异步子线程机制

* Redis主线程启动后，会使用操作系统提供的 *pthread_create* 函数创建3个子线程，分别由它们负责 *AOF日志写操作*、*键值对删除* 以及 *文件关闭* 的异步执行

* 主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成

* 实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。因此，我们把这种异步删除也称为 *惰性删除（lazy free）*。此时，删除或清空操作不会阻塞主线程，这就避免了对主线程的性能影响

* 当AOF日志配置成everysec选项后，主线程会把AOF写日志操作封装成一个任务，也放到任务队列中。后台子线程读取任务后，开始自行写入AOF日志，这样主线程就不用一直等待AOF日志写完了

* 异步的键值对删除和数据库清空操作是Redis 4.0后提供的功能，Redis也提供了新的命令来执行这两个操作

** 键值对删除：当你的集合类型中有大量元素（例如有百万级别或千万级别元素）需要删除时，使用UNLINK命令

** 清空数据库：可以在FLUSHDB和FLUSHALL命令后加上ASYNC选项，这样就可以让后台子线程异步地清空数据库


