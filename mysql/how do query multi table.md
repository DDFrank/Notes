

# 连接简介
## 连接的本质
本章使用如下数据

```sql
CREATE TABLE t1 (m1 int, n1 char(1));

CREATE TABLE t2 (m2 int, n2 char(1));

INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');

INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');

```
连接的本质就是把这个连接表中的记录都取出来依次匹配的组合加入结果集并返回

## 连接的过程
```sql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```
整个sql语句中有3个过滤条件:
- `t1.m1 > 1`
- `t2.m1 = t2.m2`
- `t2.n2 < 'd'`

大概步骤如下
- 首先确定第一个需要查询的表, 即 `驱动表`
根据过滤条件 `t1.m1 > 1` 从 `t1` 中查出全部的记录

- 针对第一步中从`驱动表`产生的结果集中的每一条记录，分别需要到 `t2`表中查找匹配的记录

根据过滤条件 `t2.m1 = t2.m2` 和 `t2.n2 < 'd' `
假设第一步查询出来的记录有2条，那么就需要查询2次 `t2` 表

## 内连接和外连接
为了解决 `驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集`的问题，产出了`内连接`和`外连接`的概念

- 对于 `内连接` 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集
- 对于 `外连接` 的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集
    - 左外连接: 选取左侧的表为驱动表
    - 右外连接: 选取右侧的表为驱动表

可以利用过滤条件进一步过滤结果集
- `WHERE` 子句中的过滤条件: 凡是不符合的都不会被加入到结果集中
- `ON` 子句中的过滤条件: 对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 `ON` 子句中的过滤条件的记录，那么该记录仍然会加入到结果集，只是被驱动表记录的各个字段使用 `NULL` 填充
    - `ON` 子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时提出的，假如是内连接，那么 `ON` 子句和 `WHERE` 子句具有同等效力

### 外连接的语法
```sql
SELECT * FROM t1 [LEFT | RIGHT ] [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
```
比较简单，略过

### 内连接的语法
```sql
SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];
```

那么，这几种SQL是等价的
```sql
SELECT * FROM t1 JOIN t2;

SELECT * FROM t1 INNER JOIN t2;

SELECT * FROM t1 CROSS JOIN t2;
```

## 连接的原理


