

# 连接简介
## 连接的本质
本章使用如下数据

```sql
CREATE TABLE t1 (m1 int, n1 char(1));

CREATE TABLE t2 (m2 int, n2 char(1));

INSERT INTO t1 VALUES(1, 'a'), (2, 'b'), (3, 'c');

INSERT INTO t2 VALUES(2, 'b'), (3, 'c'), (4, 'd');

```
连接的本质就是把这个连接表中的记录都取出来依次匹配的组合加入结果集并返回

## 连接的过程
```sql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```
整个sql语句中有3个过滤条件:
- `t1.m1 > 1`
- `t2.m1 = t2.m2`
- `t2.n2 < 'd'`

大概步骤如下
- 首先确定第一个需要查询的表, 即 `驱动表`
根据过滤条件 `t1.m1 > 1` 从 `t1` 中查出全部的记录

- 针对第一步中从`驱动表`产生的结果集中的每一条记录，分别需要到 `t2`表中查找匹配的记录

根据过滤条件 `t2.m1 = t2.m2` 和 `t2.n2 < 'd' `
假设第一步查询出来的记录有2条，那么就需要查询2次 `t2` 表

## 内连接和外连接
为了解决 `驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集`的问题，产出了`内连接`和`外连接`的概念

- 对于 `内连接` 的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集
- 对于 `外连接` 的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集
    - 左外连接: 选取左侧的表为驱动表
    - 右外连接: 选取右侧的表为驱动表

可以利用过滤条件进一步过滤结果集
- `WHERE` 子句中的过滤条件: 凡是不符合的都不会被加入到结果集中
- `ON` 子句中的过滤条件: 对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配 `ON` 子句中的过滤条件的记录，那么该记录仍然会加入到结果集，只是被驱动表记录的各个字段使用 `NULL` 填充
    - `ON` 子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时提出的，假如是内连接，那么 `ON` 子句和 `WHERE` 子句具有同等效力

### 外连接的语法
```sql
SELECT * FROM t1 [LEFT | RIGHT ] [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
```
比较简单，略过

### 内连接的语法
```sql
SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];
```

那么，这几种SQL是等价的
```sql
SELECT * FROM t1 JOIN t2;

SELECT * FROM t1 INNER JOIN t2;

SELECT * FROM t1 CROSS JOIN t2;
```

## 连接的原理
### 嵌套循环连接(Nested-Loop Join)
1. 选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询
2. 对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录
3. 有多个表进行连接的话，那么上一个步骤中两个表连接得到的结果就是新的驱动表，被连接的就是新的被驱动表，然后继续

整个过程就像是一个嵌套的循环，驱动表只会被访问一次，被驱动表却可能访问多次，访问次数取决于对驱动表执行单表查询后的结果集中的记录数，这就被称为 `嵌套循环连接`, 是最直接的一种连接查询算法

### 使用索引加快连接速度
```
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

`嵌套循环连接`的`步骤2`中可能需要访问多次被驱动表，这里如果都是全表扫描那么效率很低，所以可以利用索引进行优化

- 在 `m2` 列上建立索引, 因为对 `m2` 列的条件是等值查找，比如 `t2.m2 = 2`, `t2.m2 = 3` (驱动表查询后已经得知了要匹配的值), 所以可能使用到 `ref` 的访问方法，假如使用了 `ref` 方法，那么就需要回表之后再判断 `t2.n2 < d` 这个条件是否成立
    - 假如 `m2` 是 `t2`表的主键或者唯一二级索引列，那么使用 `t2.m2`这样的条件从 `t2` 表中查询记录的过程就是常数级别。这种在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为: `eq_ref`

- 在 `n2` 上建立索引，涉及到的条件是 `t2.n2 < 'd'`，可能用到 `range` 的访问方法

### 基于块的嵌套循环连接(Block Nested-Loop Join)
- 当被驱动表中的数据非常多的时候，每次访问被驱动表，被驱动表的记录会被加载到内存中，在内冲中的每一条记录只会和驱动表结果集的一条记录做匹配，之后就会被从内存里清除掉。
- `join buffer` 在执行连接查询前申请一块固定大小的内存，先把若干驱动表结果集中的记录装在 `join buffer` 中，然后开始扫描被驱动表，每一条被驱动表的记录一次性和`join buffer` 中的多条驱动表记录做匹配，这样可以显著减少 `I/O`代价
- 这种加入了 `join buffer` 的嵌套循环连接算法称之为 `基于块的嵌套连接`算法
- `join buffer` 块的大小可以通过 启动参数或者系统变量 `join_buffer_size` 进行配置，默认大小为 `256kb`
- 只有查询子句中的列才会被放入 `join buffer`,所以要避免 `select *`

