# 理论知识
## 解决并发事务带来问题的两种基本方式
### 并发事务访问相同记录的情况大致可以划分为3种:
- `读-读`情况: 即并发事务相继读取相同的记录
不会有任何问题，允许

- `写-写`情况: 即并发事务相继对相同的记录做出改动
会发生`脏写`的问题
所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过`锁`来实现的

- `读-写`或`写-读`情况：也就是一个事务进行读取操作，另一个进行改动操作
这种情况下可能发生`脏读、不可重复读、幻读`的问题
解决这个问题，一是可以使用 `MVCC`来解决，二就是加锁进行读取
加锁进行读取意味着，`读`操作和`写`操作也像`写-写`操作那样排队

很明显，采用`MVCC`方式的话，`读-写`操作彼此并不冲突，性能更高，采用`加锁方式`的话，`读-写`操作彼此需要排队执行，影响性能。
一般情况下采用`MVCC`来解决`读-写`操作并发执行的问题，但是业务在某些特殊情况下，必须采用加锁的方式执行。

### 一致性读
事务利用`MVCC`进行的读取操作称之为`一致性读`，或者`一致性无锁读`，有的地方也称之为`快照读`。所有普通的`SELECT`语句（`plain SELECT`）在`READ COMMITTED`、`REPEATABLE READ`隔离级别下都算是`一致性读`

`一致性读`并不会对表中的任何记录做`加锁`操作，其他事务可以自由的对表中的记录做改动

### 锁定读(Locking Reads)
#### 共享锁和独占锁
- `共享锁`，(`Shared Locks`)，简称`S锁`。在事务要读取一条记录时，需要先获取该记录的`S锁`
- `独占锁`，也常称`排他锁`，`Exclusive Locks`，简称X锁。在事务要改动一条记录时，需要先获取该记录的X锁

假如事务`T1`首先获取了一条记录的`S锁`之后，事务`T2`接着也要访问这条记录:
- 如果事务`T2`想要再获取一个记录的`S锁`，那么事务`T2`也会获得该锁，也就意味着事务`T1`和`T2`在该记录上同时持有`S锁`(都可以读)
- 如果事务`T2`想要再获取一个记录的`X锁`，那么此操作会被阻塞，直到事务`T1`提交之后将`S锁`释放掉

如果事务`T1`首先获取了一条记录的`X锁`之后，那么不管事务`T2`接着想获取该记录的`S锁`还是`X锁`都会被阻塞，直到事务`T1`提交

#### 锁定读的语句
有时候想在读取记录时就获取记录的`X锁`，来禁止别的事务读写该记录, 可以使用两种比较特殊的`SELECT`语句:
- 对读取的记录加`S锁`
```sql
SELECT ... LOCK IN SHARE MODE;
```
- 在普通的`SELECT`语句后边加`LOCK IN SHARE MODE`，如果当前事务执行了该语句，那么它会为读取到的记录加`S锁`，这样允许别的事务继续获取这些记录的`S锁`（比方说别的事务也使用`SELECT ... LOCK IN SHARE MODE`语句来读取这些记录），但是不能获取这些记录的`X锁`（比方说使用`SELECT ... FOR UPDATE`语句来读取这些记录，或者直接修改这些记录）。
- 如果别的事务想要获取这些记录的`X锁`，那么它们会阻塞，直到当前事务提交之后将这些记录上的`S锁`释放掉

- 对读取的记录加`X锁`:
```sql
SELECT ... FOR UPDATE;
```
- 在普通的`SELECT`语句后边加`FOR UPDATE`，如果当前事务执行了该语句，那么它会为读取到的记录加`X锁`，这样既不允许别的事务获取这些记录的`S锁`（比方说别的事务使用`SELECT ... LOCK IN SHARE MODE`语句来读取这些记录），也不允许获取这些记录的`X锁`（比如说使用`SELECT ... FOR UPDATE`语句来读取这些记录，或者直接修改这些记录）。
- 如果别的事务想要获取这些记录的S锁或者X锁，那么它们会阻塞，直到当前事务提交之后将这些记录上的X锁释放掉

### 写操作
#### DELETE
- 对一条记录做`DELETE`操作的过程其实是先在`B+`树中定位到这条记录的位置，然后获取一下这条记录的`X锁`，然后再执行`delete mark`操作。
- 也可以把这个定位待删除记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`

#### UPDATE:
分三种情况
- 如果未修改该记录的`主键`并且被更新的列占用的存储空间在修改前后未发生变化，则先在`B+`树中定位到这条记录的位置，然后再获取一下记录的`X锁`，最后在原记录的位置进行修改操作。也可以把这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`
- 如果未修改该记录的`主键`并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在`B+`树中定位到这条记录的位置，然后获取一下记录的`X锁`，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`，新插入的记录由`INSERT`操作提供的`隐式锁`进行保护
- 如果修改了该记录的键值，则相当于在原记录上做`DELETE`操作之后再来一次`INSERT`操作，加锁操作就需要按照`DELETE`和`INSERT`的规则进行了

#### INSERT
一般情况下，新插入一条记录的操作并不加锁，`InnoDB`规定通过一种称之为`隐式锁`的机制来保护这条新插入的记录在本事务提交前不被别的事务访问

## 多粒度锁
一个事务也可以在`表`级别进行加锁，自然就被称之为`表级锁`或者`表锁`，对一个表加锁影响整个表中的记录，称之为`粗粒度`的锁。给表加的锁也可以分为`共享锁（S锁）`和`独占锁（X锁）`

- 给表加`S锁`: 如果一个事务给表加了`S锁`，那么
    * 别的事务可以继续获得该表的`S锁`
    * 别的事务可以继续获得该表中的某些记录的`S锁`
    * 别的事务不可以继续获得该表的`X锁`
    * 别的事务不可以继续获得该表中的某些记录的`X锁`

- 给表加`X锁`: 如果一个事务给表加了`X锁`（意味着该事务要独占这个表），那么
    * 别的事务不可以继续获得该表的`S锁`
    * 别的事务不可以继续获得该表中的某些记录的`S锁`
    * 别的事务不可以继续获得该表的`X锁`
    * 别的事务不可以继续获得该表中的某些记录的`X锁`

### 意向锁 (Intention Locks)
- 意向共享锁，英文名：`Intention Shared Lock`，简称`IS锁`。当事务准备在某条记录上加`S锁`时，需要先在表级别加一个`IS锁`
假如想要在对某个表加`S锁`的时候，就先看看表上是否有`IX`锁，如果有的话，就阻塞到`IX`锁释放

- 意向独占锁，英文名：`Intention Exclusive Lock`，简称`IX锁`。当事务准备在某条记录上加`X锁`时，需要先在表级别加一个`IX锁`
假如想要在表上加`X锁`时，需要看一下表上是否已经有`IX`锁或`IS`锁，如果有，那么需要阻塞到`IX`和`IS`释放后


`IS`、`IX`锁是表级锁，它们的提出仅仅为了在之后加表级别的`S锁`和`X锁`时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实`IS`锁和`IX`锁是兼容的，`IX`锁和`IX`锁是兼容的


# MySQL中的行锁和表锁
## 其它存储引擎中的锁
对于`MyISAM`、`MEMORY`、`MERGE`这些存储引擎来说，它们只支持表级锁，而且这些引擎并不支持事务，所以使用这些存储引擎的锁一般都是针对当前会话来说的。比方说在`Session 1`中对一个表执行`SELECT`操作，就相当于为这个表加了一个表级别的`S锁`，如果在`SELECT`操作未完成时，`Session 2`中对这个表执行`UPDATE`操作，相当于要获取表的`X锁`，此操作会被阻塞，直到`Session 1`中的`SELECT`操作完成，释放掉表级别的`S锁`后，`Session 2`中对这个表执行`UPDATE`操作才能继续获取`X锁`，然后执行具体的更新语句

## InnoDB存储引擎中的锁
### 表级锁
#### 表级别的 S锁，X锁
- 在对某个表执行`SELECT`、`INSERT`、`DELETE`、`UPDATE`语句时，`InnoDB`存储引擎是不会为这个表添加表级别的`S锁`或者`X锁`的
- 在对某个表执行一些诸如`ALTER TABLE`、`DROP TABLE`这类的`DDL`语句时，其他事务对这个表并发执行诸如`SELECT`、`INSERT`、`DELETE`、`UPDATE`的语句会发生阻塞，同理，某个事务中对某个表执行`SELECT`、`INSERT`、`DELETE`、`UPDATE`语句时，在其他会话中对这个表执行`DDL`语句也会发生阻塞。这个过程其实是通过在`server`层使用一种称之为`元数据锁`（`Metadata Locks`，简称`MDL`）的机制来实现的，一般情况下也不会使用`InnoDB`存储引擎自己提供的表级别的`S锁`和`X锁`
- `InnoDB`存储引擎提供的表级`S锁`或者`X锁`是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到
- 在在系统变量`autocommit=0，innodb_table_locks = 1`时，手动获取`InnoDB`存储引擎提供的表`t`的`S锁`或者`X锁`可以这么写:
    * `LOCK TABLES t READ`：`InnoDB`存储引擎会对表`t`加表级别的`S锁`
    * `LOCK TABLES t WRITE`：`InnoDB`存储引擎会对表`t`加表级别的`X锁`
- 尽量不要使用手动缩表语句

#### 表级别的IS锁, IX锁
- 在对使用`InnoDB`存储引擎的表的某些记录加`S锁`之前，那就需要先在表级别加一个`IS`锁
- 当对使用`InnoDB`存储引擎的表的某些记录加`X锁`之前，那就需要先在表级别加一个`IX`锁。
- `IS`锁和`IX`锁的使命只是为了后续在加表级别的`S`锁和`X`锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录

#### 表级别的AUTO-INC锁
主要是用来实现`AUTO_INCREMENT`机制的
- 采用`AUTO-INC`锁，也就是在执行插入语句时就在表级别加一个`AUTO-INC`锁，然后为每条待插入记录的`AUTO_INCREMENT`修饰的列分配递增的值，在该语句执行结束后，再把`AUTO-INC`锁释放掉。这样一个事务在持有`AUTO-INC`锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。
如果插入语句在执行前不可以确定具体要插入多少条记录（无法预计即将插入记录的数量），比方说使用`INSERT ... SELECT`、`REPLACE ... SELECT`或者`LOAD DATA`这种插入语句，一般是使用`AUTO-INC`锁为`AUTO_INCREMENT`修饰的列生成对应的值
这个`AUTO-INC`锁的作用范围只是单个插入语句，插入语句执行完成后，这个锁就被释放了，不是在事务结束时释放。

- 采用一个轻量级的锁，在为插入语句生成`AUTO_INCREMENT`修饰的列的值时获取一下这个轻量级锁，然后生成本次插入语句需要用到的`AUTO_INCREMENT`列的值之后，就把该轻量级锁释放掉，并不需要等到整个插入语句执行完才释放锁

- `InnoDB`中设计了一个`innodb_autoinc_lock_mode`的系统变量来控制到底使用上述两种方式中的哪种来为`AUTO_INCREMENT`修饰的列进行赋值，当`innodb_autoinc_lock_mode`值为`0`时，一律采用`AUTO-INC`锁；当`innodb_autoinc_lock_mode`值为`2`时，一律采用轻量级锁；当`innodb_autoinc_lock_mode`值为`1`时，两种方式混着来

### InnoDB中的行级锁
假设使用该表
```sql
CREATE TABLE hero (
    number INT,
    name VARCHAR(100),
    country varchar(100),
    PRIMARY KEY (number)
) Engine=InnoDB CHARSET=utf8;
```

`InnoDB`中的行锁有多种类型
#### Record Locks(LOCK_REC_NOT_GAP)
- 仅仅把一条记录锁上, 以下简称为`正经记录锁(LOCK_REC_NOT_GAP)`
- 正经记录锁是有`S锁`和`X锁`之分的
- 当一个事务获取了一条记录的`S型正经记录锁`后，其他事务也可以继续获取该记录的`S型正经记录锁`，但不可以继续获取`X型正经记录锁`
- 当一个事务获取了一条记录的`X型正经记录锁`后，其他事务既不可以继续获取该记录的`S型正经记录锁`，也不可以继续获取`X型正经记录锁`

#### Gap Locks (LOCK_GAP)
- 该锁主要用于使用`加锁`方案来解决`幻读`问题
- 在第一次读取记录时，可以给记录加上`gap锁`, 假设记录的id为8
- 那么该锁就不允许别的事务在`id`为`8`的记录和前边的记录(假设`id`为`3`)的间隙间插入记录(也就是 (`3`,`8`)之间不允许插入记录)
- 假如要插入一个`id`为`4`的新纪录，那么就会阻塞直到 `gap锁`释放
- 这个`gap锁`的提出仅仅是为了防止插入幻影记录而提出的，虽然有`共享gap锁`和`独占gap锁`这样的说法，但是它们起到的作用都是相同的
- 数据页有`2`条伪纪录, 
    * `Infimum`记录，表示该页面中最小的记录
    * `Supremum`记录，表示该页面中最大的记录
- 那么只要给 `Supremum` 加上 `gap锁`, 就可以阻止事务插入 页面实际最小主键纪录后面数据

#### Next-Key Locks (LOCK_ORDINARY)
- 有时候既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录, 可以使用 `Next-Key Locks` 锁
- `Next-Key Locks`锁的本质就是一个`正经记录锁`和一个`gap锁`的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙

#### Insert Intention Locks(LOCK_INSERT_INTENTION)
- 一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的`gap锁`（`next-key锁`也包含`gap锁`），如果有的话，插入操作需要等待，直到拥有`gap锁`的那个事务提交
- 事务在等待的时候也需要在内存中生成一个`锁结构`，表明有事务想在某个`间隙`中插入新记录，但是现在在等待
- 这个锁就是`Insert Intention Locks`(LOCK_INSERT_INTENTION), 称为`插入意向锁`
- 插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁

#### 隐式锁
- 假如一个事务插入了一条纪录(此时没有与该纪录相关联的锁结构), 那么另外一条纪录:
    * 立即使用`SELECT ... LOCK IN SHARE MODE`语句读取这条记录，也就是在要获取这条记录的`S锁`，或者使用`SELECT ... FOR UPDATE`语句读取这条记录，也就是要获取这条记录的`X锁`
    * 立即修改这条记录，也就是要获取这条记录的`X锁`
允许立即读的话可能产生`脏读`问题，允许立即修改的话可能产生`脏写`问题

- 此时`事务id`会保证加入一个`隐式锁`
    * 对于聚簇索引记录来说，有一个`trx_id`隐藏列，该隐藏列记录着最后改动该记录的`事务id`。那么如果在当前事务中新插入一条聚簇索引记录后，该记录的`trx_id`隐藏列代表的的就是当前事务的事务id，如果其他事务此时想对该记录添加`S锁`或者`X锁`时，首先会看一下该记录的`trx_id`隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个`X锁`（也就是为当前事务创建一个锁结构，`is_waiting`属性是`false`），然后自己进入等待状态（也就是为自己也创建一个锁结构，`is_waiting`属性是`true`）
    * 对于二级索引记录来说，本身并没有`trx_id`隐藏列，但是在二级索引页面的`Page Header`部分有一个`PAGE_MAX_TRX_ID`属性，该属性代表对该页面做改动的最大的`事务id`，如果`PAGE_MAX_TRX_ID`属性值小于当前最小的`活跃事务id`，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录，然后再重复`上一步`的做法
- 所以一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），但是由于`事务id`的存在，相当于加了一个隐式锁。别的事务在对这条记录加`S锁`或者`X锁`时，由于`隐式锁`的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态

### InnoDB锁的内存结构
- 对一条记录加锁的本质就是在内存中创建一个锁结构与之关联
- 但是一个事务对多条锁加锁，不一定要创建多个锁结构

当对不同的记录加锁时，如果符合下边的条件:
- 在同一个事务中进行加锁操作
- 被加锁的记录在同一个页面中
- 加锁的类型是一样的
- 等待状态是一样的
那么这些记录的锁就可以被放到一个`锁结构`中

#### InnoDB存储引擎事务锁结构
- `锁所在的事务信息`: 不论是`表锁`还是`行锁`，都是在事务执行过程中生成的，哪个事务生成了这个锁结构，这里就记载着这个事务的信息
- `索引信息`: 对于`行锁`来说，需要记录一下加锁的记录是属于哪个索引的
- `表锁／行锁信息`, 两个锁这个部分的信息不一样
    * `表锁`: 记载着这是对哪个表加的锁，还有其他的一些信息
    * `行锁`: 
        - `Space ID`：记录所在表空间
        - `Page Number`：记录所在页号
        - `n_bits`：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个`n_bits`属性代表使用了多少比特位
- `type_mode`: 这是一个32位的数，被分成了`lock_mode`、`lock_type`和`rec_lock_type`三个部分
    * 锁的模式(lock_mode), 占用低4位，值如下:
        - `LOCK_IS`（十进制的`0`）：表示共享意向锁，也就是`IS锁`
        - `LOCK_IX`（十进制的`1`）：表示独占意向锁，也就是`IX锁`
        - `LOCK_S`（十进制的`2`）：表示共享锁，也就是`S锁`
        - `LOCK_X`（十进制的`3`）：表示独占锁，也就是`X锁`
        - `LOCK_AUTO_INC`（十进制的`4`）：表示`AUTO-INC锁`
    * 所得类型(`lock_type`), 占用5 ~ 8 位,不过现阶段只有5, 6 位被使用
        - `LOCK_TABLE`（十进制的`16`），也就是当第5个比特位置为1时，表示表级锁
        - `LOCK_REC`（十进制的`32`），也就是当第6个比特位置为1时，表示行级锁
    * 行锁的具体类型（`rec_lock_type`），使用其余的位来表示。只有在`lock_type`的值为`LOCK_REC`时，也就是只有在该锁为行级锁时，才会被细分为更多的类型:
        - `LOCK_ORDINARY`（十进制的`0`）：表示`next-key锁`
        - `LOCK_GAP`（十进制的`512`）：也就是当第10个比特位置为`1`时，表示`gap锁`
        - `LOCK_REC_NOT_GAP`（十进制的`1024`）：也就是当第`11`个比特位置为`1`时，表示`正经记录锁`
        - `LOCK_INSERT_INTENTION`（十进制的`2048`）：也就是当第12个比特位置为1时，表示`插入意向锁`
        - `其它`：不常用，忽略
- `is_waiting`: `is_waiting`属性在`type_mode`这个`32`位的数字:
    * `LOCK_WAIT`（十进制的`256`） ：也就是当第9个比特位置为`1`时，表示`is_waiting`为`true`，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为`0`时，表示`is_waiting`为`false`，也就是当前事务获取锁成功

- `其它信息`: 为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表, 忽略掉

- `一堆bit`: 
如果是`行锁结构`的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的`n_bits`属性表示的
页面中的每条记录在记录头信息中都包含一个`heap_no`属性，伪记录`Infimum`的`heap_no`值为`0`，`Supremum`的`heap_no`值为`1`，之后每插入一条记录，`heap_no`值就增1。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个`heap_no`

## 语句加锁分析


