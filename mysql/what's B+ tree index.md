### 没有索引的查找
假如没有主键，那么就只能遍历了，显然是非常低效和耗时的

# InnoDB 的索引方案
## B+树的由来
- 为了快速方便的定位数据页中的数据，发明了 `目录数据页`，其中装的全部是 `目录项记录`
- 记录头信息的值就是用来区分的
  - 0 普通的用户记录
  - 1 目录项记录
  - 2 最小记录
  - 3 最大记录

### `目录项记录` 和 `用户记录` 的不同点
- `record_type` 不同
- `目录项记录` 只有主键值和页的编号两个列。而普通的用户记录的页是用户自己定义的，可能包含很多列。还有隐藏列
- 记录头信息的 `min_rec_mask` 属性，只有在存储 `目录项记录`的页中的主键值最小的`目录项记录` 的 `min_rec_mask` 值为1, 其他别的记录的 `min_rec_mask` 的值都是0

那么，当目录越来越多时，就会出现记录目录的目录，于是就越长越高，成为了 B+树
感觉跟跳表的结构很像

- 实际用户记录其实都存放在B+树的最底层的节点上，这些节点称为 `叶节点`
- 其余用来存放 `目录项`的节点称为 `非叶子节点` 或 `内节点`
- `B+` 树最底层的节点称为 `根节点`

## 聚簇索引
`B+`树本身就是一个目录, 或者说本身就是一个索引，有2个特点

### 使用记录主键值的大小进行记录和页的排序
- 页内的记录是按照主键的大小顺序排成一个单向链表
- 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表
- 存放目录记录的页分为不同的层次，在同一层次的页也是根据页中目录记录的主键大小排成一个双向链表

### `B+`树的叶子节点存储的是完成的用户记录
所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)

具有以上两种特性的 `B+` 树称为 `聚簇索引`
- 所有完整的用户记录都存放在这个 `聚簇索引`的叶子节点处。
- `InnoDB` 存储引擎会自动为我们创建聚簇索引
- `InnoDB` 存储引擎中，`聚簇索引` 就是数据的存储方式
  
## 二级索引
假如想根据非主键的列来查找数据，那么可以为该列另外建一个 `B+树`

### 和 聚簇索引的不同处 （以 c 列举例）
- 使用 `c2` 列的大小进行记录和页的排序。
- `B+树`的叶子节点存储的并不是完整的用户记录，而只是`c2列+主键` 这两个列的值
- 目录项记录中不再是 `主键+页号`的搭配，而变成了`c2+页号`的搭配

### 使用 c2 列进行查询的过程
1. 确定`目录项记录`页
    根据 `根页面`， 快速定位到 `目录项记录` 所在页
2. 通过 `目录项记录`页确定用户记录真实所在的页
3. 到真实存储用户记录的页中定位到具体的记录
4. 因为只获取到了主键，所以为了获取完整的用户记录必须再利用主键去遍历一遍 `聚簇索引`

上述到`聚簇索引`中再遍历一遍的做法称为 `回表`

所以因为这种按照 `非主键列`建立的`B+树`需要一次`回表`操作才可以定位到完整的用户记录，所以这种索引称为 `二级索引` 或 `辅助索引`

## 联合索引

也可以同时以多个列的大小作为排序规则，比如想让 `B+`树按照 `c2` 和 `c3` 列的大小进行排序

- 先把各个记录和页按照 `c2`列进行排序
- 在记录的`c2`列相同的情况下，采用`c3`列进行排序
- 每条`目录项记录` 都由 `c2`, `c3`, `页号` 这三个部分组成
- `B+`树叶子节点处的用户记录由`c2`,`c3`和主键列组成
- 本质上还是二级索引

## 一些注意事项

- 根页面不会移动

  - 每当为某个表创建一个`B+`树索引的时候(聚簇索引默认就有)，都会为这个索引创建一个`根节点`页面。最开始没有数据的时候，`根节点`中既没有用户记录，也没有目录项记录
  - 随后向表中插入用户记录时，先把用户记录存储到这个`根节点`中
  - 当`根节点`中的可用空间用完时继续插入记录，此时会将`根节点`中的所有记录复制到一个新分配的页中, 然后通过 `页分裂` ，得到一个新的页。此时新插入的记录根据键值会被分配到新的页，那么`根节点`也就升级成为存储目录记录的页。
  - `根节点`自诞生之日起，就不会再移动


- 内节点中目录项记录的唯一性

二级索引的内节点的目录项记录的内容实际上是由三个部分构成的

  - 索引列的值
  - 主键值
  - 页号

这样可以利用主键保证 `B+`树每一层节点中各条目录项记录除`页号`这个字段外是唯一的



- 一个页面最少存储2条记录

## B+树索引的使用

