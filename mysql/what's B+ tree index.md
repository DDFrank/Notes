### 没有索引的查找
假如没有主键，那么就只能遍历了，显然是非常低效和耗时的

# InnoDB 的索引方案
## B+树的由来
- 为了快速方便的定位数据页中的数据，发明了 `目录数据页`，其中装的全部是 `目录项记录`
- 记录头信息的值就是用来区分的
  - 0 普通的用户记录
  - 1 目录项记录
  - 2 最小记录
  - 3 最大记录

### `目录项记录` 和 `用户记录` 的不同点
- `record_type` 不同
- `目录项记录` 只有主键值和页的编号两个列。而普通的用户记录的页是用户自己定义的，可能包含很多列。还有隐藏列
- 记录头信息的 `min_rec_mask` 属性，只有在存储 `目录项记录`的页中的主键值最小的`目录项记录` 的 `min_rec_mask` 值为1, 其他别的记录的 `min_rec_mask` 的值都是0

那么，当目录越来越多时，就会出现记录目录的目录，于是就越长越高，成为了 B+树
感觉跟跳表的结构很像

- 实际用户记录其实都存放在B+树的最底层的节点上，这些节点称为 `叶节点`
- 其余用来存放 `目录项`的节点称为 `非叶子节点` 或 `内节点`
- `B+` 树最底层的节点称为 `根节点`

## 聚簇索引
`B+`树本身就是一个目录, 或者说本身就是一个索引，有2个特点

### 使用记录主键值的大小进行记录和页的排序
- 页内的记录是按照主键的大小顺序排成一个单向链表
- 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表
- 存放目录记录的页分为不同的层次，在同一层次的页也是根据页中目录记录的主键大小排成一个双向链表

### `B+`树的叶子节点存储的是完成的用户记录
所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)

具有以上两种特性的 `B+` 树称为 `聚簇索引`
- 所有完整的用户记录都存放在这个 `聚簇索引`的叶子节点处。
- `InnoDB` 存储引擎会自动为我们创建聚簇索引
- `InnoDB` 存储引擎中，`聚簇索引` 就是数据的存储方式
  
## 二级索引
假如想根据非主键的列来查找数据，那么可以为该列另外建一个 `B+树`

### 和 聚簇索引的不同处 （以 c 列举例）
- 使用 `c2` 列的大小进行记录和页的排序。
- `B+树`的叶子节点存储的并不是完整的用户记录，而只是`c2列+主键` 这两个列的值
- 目录项记录中不再是 `主键+页号`的搭配，而变成了`c2+页号`的搭配

### 使用 c2 列进行查询的过程
1. 确定`目录项记录`页
    根据 `根页面`， 快速定位到 `目录项记录` 所在页
2. 通过 `目录项记录`页确定用户记录真实所在的页
3. 到真实存储用户记录的页中定位到具体的记录
4. 因为只获取到了主键，所以为了获取完整的用户记录必须再利用主键去遍历一遍 `聚簇索引`

上述到`聚簇索引`中再遍历一遍的做法称为 `回表`

所以因为这种按照 `非主键列`建立的`B+树`需要一次`回表`操作才可以定位到完整的用户记录，所以这种索引称为 `二级索引` 或 `辅助索引`

## 联合索引

也可以同时以多个列的大小作为排序规则，比如想让 `B+`树按照 `c2` 和 `c3` 列的大小进行排序

- 先把各个记录和页按照 `c2`列进行排序
- 在记录的`c2`列相同的情况下，采用`c3`列进行排序
- 每条`目录项记录` 都由 `c2`, `c3`, `页号` 这三个部分组成
- `B+`树叶子节点处的用户记录由`c2`,`c3`和主键列组成
- 本质上还是二级索引

## 一些注意事项

- 根页面不会移动

  - 每当为某个表创建一个`B+`树索引的时候(聚簇索引默认就有)，都会为这个索引创建一个`根节点`页面。最开始没有数据的时候，`根节点`中既没有用户记录，也没有目录项记录
  - 随后向表中插入用户记录时，先把用户记录存储到这个`根节点`中
  - 当`根节点`中的可用空间用完时继续插入记录，此时会将`根节点`中的所有记录复制到一个新分配的页中, 然后通过 `页分裂` ，得到一个新的页。此时新插入的记录根据键值会被分配到新的页，那么`根节点`也就升级成为存储目录记录的页。
  - `根节点`自诞生之日起，就不会再移动


- 内节点中目录项记录的唯一性

二级索引的内节点的目录项记录的内容实际上是由三个部分构成的

  - 索引列的值
  - 主键值
  - 页号

这样可以利用主键保证 `B+`树每一层节点中各条目录项记录除`页号`这个字段外是唯一的



- 一个页面最少存储2条记录

## B+树索引的使用

以下为表的例子

```sql
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```
该表主键是 id
有一个联合索引 (name, birthday, phone_number)

### 全值匹配
```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```
全部是索引列，所以 按照顺序逐步定位

### 匹配左边的列

```sql
SELECT * FROM person_info WHERE birthday = '1990-09-27';
```
这个sql因为 birthday不是最左边开始的索引，所以利用不到索引

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND phone_number = '15123983239';
```
这个只能利用到 `name` 列的索引而无法利用 `phone_number`

### 匹配列前缀
针对字符串的索引列，因为字符串列的前缀是已经排好序的
```sql
SELECT * FROM person_info WHERE name LIKE 'As%';
```
这个也可以利用到索引

```sql
SELECT * FROM person_info WHERE name LIKE '%As%';
```
这个就利用不到索引
所以有时候可以安排逆序存储字符串来提高查询效率

### 匹配范围值

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```
这个可以利用到索引，分别找到 `Asa` 和 `Barlow` 的记录，然后 去 `聚簇索引`中 `回表` 查询完整的用户记录

如果对多个列进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到 `B+` 树索引
```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';
```
这个就只能利用到 `name` 的索引

### 精确匹配某一列并范围匹配另外一列

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```
- 对 `name = ‘Ashburn’` 进行精确匹配，可以利用到索引
- 因为 `name` 列是精确查找的，所以第一步得到的结果的 `name` 都是相同的，按照 `birthday` 排序的，所以对 `birthday` 列进行范围查找是可以利用索引的
- 第二步中得到的 `birthday` 不是相同的，因此无法利用索引了

### 用于排序
- 使用 `ORDER BY` 排序的时候，有时候可能查询的结果集太大以至于不能在内存中进行排序时，可能需要借助磁盘的空间来存放中间结果。这种在内存或磁盘上排序的方式称为 `文件排序`
- 假如 `ORDER BY` 子句中使用了索引列，那么可能省去排序的步骤，因为索引里已经排好序了，那么直接取出即可

#### 使用联合索引进行排序的注意事项
- `ORDER BY` 的子句后边的列的顺序也必须按照索引列的顺序给出, 不然就利用不了索引

#### 无法利用索引进行排序的几种情况
- ASC, DESC 混用
如果利用索引可能还不如文件排序快

- 排序列使用了复杂的表达式

### 用于分组
```sql
SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number
```
因为分组的顺序和联合索引排序的顺序一致，所以可以利用素银来分组

## 回表的代价
```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```
- 从二级索引中取出 `name` 的目录项记录, 因为排好序了，所以是`顺序I/O`
- `回表`查询完整的用户记录, 因为主键的顺序并不确定，所以是 `随机I/O`
- 需要回表的记录越多，使用二级索引的性能就越低，所以有些时候，假如回表的记录实在过多，可以考虑使用全表查询
- 有 `LIMIT` 子句的语句倾向于使用 `二级索引 + 回表`

### 覆盖索引
- 为了避免 `回表` 操作带来的性能损耗，最好在查询列表里只包含索引列
- 这种只需要用到索引的查询方式称为 `覆盖索引`
- 排序操作也最好使用 `覆盖索引`的方式进行查询

## 如何挑选索引

- 只为用于搜索, 排序或分组的列创建索引
也就是 `where` 子句, `order by` 子句 和 `group by` 子句

- 考虑列的基数
  - 列的基数是指某一列中不重复数据的个数
  - 记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中
  - 最好为基数大的列建立索引，因为基数小的列重复的值多，排序意义不大

- 索引列的类型尽量小
  - 数据类型越小，在查询时进行的比较操作就越快
  - 数据类型越小，索引占用的存储空间就越少，在一个数据页内就能放下更多的记录，从而减少磁盘`I/O`带来的性能损耗，也就可以缓存更多的数据页，提高读写效率

## 索引字符串值的前缀
因为存储字符串顺序对空间的要求比较大，所以可以在设置字符串索引的时候只对前几个字符进行索引

```sql
CREATE TABLE person_info(
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);  
```
推荐在字符串存储的字符比较多的时候设置

### 使用索引列前缀的时候，无法使用索引列对文件排序
因为 `name` 列包含的信息不完整，所以只能使用文件排序

## 让索引列在比较表达式中单独出现

```sql
where my_col * 2 < 4
```
```sql
where my_col < 4/2
```
第一个 `where` 子句中的 `my_col` 列并不是以单独的列的形式出现的，所以存储引擎会依次遍历所有的记录，所以利用不了索引

但是第二个子句就可以利用，因为 `my_col` 是单独列而不是表达式

## 主键插入顺序
- 主键的插入顺序如果忽大忽小，那么就更容易发生`页分裂` 和 `记录位移`，带来性能损耗
- 假如主键值能依次递增，那么就可以避免这样的问题





