# InnoDB 记录结构
- InnoDB 是将数据划分为页进行保存的
- 页是磁盘和内存之间交换的基本单位
- 页的大小一般为 16 KB

## InnoDB 行格式
- 数据是以记录为单位存入数据表中的
- 这些记录在磁盘上的存放方式被称为行格式或者记录格式

目前有4种格式
- Compact
- Redundant
- Dynamic
- Compressed

## 指定行格式的语法
```sql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

## COMPACT行格式

一条记录由额外信息和真实数据组成

### 额外信息
服务器为了描述记录而不得不添加的一些信息

#### 变长字段长度列表
- 针对于变长数据类型，需要额外存储其占用的字节数
- 各变长字段数据占用的字节数按照列的顺序`逆序`存放
- 变长字段长度列表中只存储值为 `非NULL` 的列内容占用的长度
- `NUll` 的的列的长度是不存储的 

PS: InnoDB 如何判断使用 1 字节 还是 2 字节来表示数据的字节数
- `w` 为某个字符集中最多需要使用的字节数为, 比如 `utf8` 中的 `w`是3, `gbk`中是2
- 对于变长类型VARCHAR(M)来说，这种类型表示能存储最多 `M` 个字符, 那么这个类型能表示的字符串最多能占用的字节数就是 `M * W`
- 假设实际存储的字符串占用的字节数是 `L`

那么 如果 `M * W <= 255`，那么使用一个字节来存储
如果 `M * W > 255` 且 `L <= 127` 那么使用 1 个字节来表示
如果 `M * W > 255` 且 `L > 127` 那么使用 2 个字节来表示



#### NULL值列表
  专门用来记录值为 `NULL`的列的结构
  - 首先统计允许存储 `NULL` 的列是哪些
  - 如果没有能存`NULL`的列，那么就没有 `NULL值列表`,否则会将每个允许存储`NULL` 的列对应一个二进制位，二进制位按照列的顺序逆序排列，1 表示 NULl,0 表示不为NULL
  - 如果二进制个数不是整数个字节，那么在字节的高位补0
#### 记录头信息
由固定的5个字节40个二进制位组成，不同的位代表不同的意思，详细信息

| 名称         | 大小(bit) | 描述                                         |
| ------------ | --------- | -------------------------------------------- |
| 预留位1      | 1         | 没有使用                                     |
| 预留位2      | 1         | 没有使用                                     |
| delete_mask  | 1         | 标记该记录是否被删除                         |
| min_rec_mask | 1         | B+树的每层叶子节点中的最小记录都会添加该标记 |
| n_owned      | 4         | 表示当前记录拥有的记录数                     |
| heap_no      | 13        | 表示当前记录在记录堆的位置信息               |
| record_type  | 3         | 表示当前记录的类型                           |
| next_record  | 16        | 表示下一条记录的相对位置                     |



### 记录的真实数据
除了真实数据外，MYSQL会为每个记录默认的添加一些列(隐藏列)

| 列名        | 是否必须 | 占用空间 | 描述                   |
| ----------- | -------- | -------- | ---------------------- |
| DB_ROW_ID   | 否       | 6字节    | 行ID，唯一标识一条记录 |
| DB_TRX_ID   | 是       | 6字节    | 事务Id                 |
| DB_ROLL_PTR | 是       | 7字节    | 回滚指针               |

`PS`: InnoDB 表对主键的生成策略:

- 优先使用用户自定义主键作为主键
- 没有定义主键的话，选择一个 `Unique`约束作为主键
- 连 `Unique`都没有的话，`InnoDB` 会为表默认添加一个名为 `DB_ROW_ID`的隐藏列作为主键

### CHAR(M)列的存储格式
- 如果列是定长的字符集,比如说 `ascii`, 那么该列占用的字节数不会被添加到变长字段长度列表
- 如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表

### 行溢出数据
- COMPACT的处理办法
对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据,然后把剩余的数据分散存储在几个其它的页中，然后`记录的真实数据`处用20个字节存储指向这些页的地址


## Redundant行格式
MySql 5.0 之前采用的一种格式，不是很重要了

## Dynamic 和 Compressed 行格式
- 基本类似于 `COMPACT` 行格式
- 处理行数据溢出时，不会在`记录的真实数据处`存储字符串的前768个字节, 而是把所有的字节都存储到其他页面中，只在`记录的真实数据处`存储其它页面的地址
- `Compressed` 行格式会采用压缩算法对页面进行压缩

# InnoDB 数据页结构

| 名称        | 中文名  | 占用空间大小 | 简单描述                  |
|-------------|---------|--------|---------------------|
| File Header   | 文件头部       | 38字节    | 页的一些通用信息 |
| PAGE Header   | 页面头部       | 56字节    | 数据页专有的一些信息                |
| Infimum + Supermum | 最小和最大记录       | 26字节    | 两个虚拟的行记录              |
| User Records | 用户记录       | 不确定    | 实际存储的行记录内容              |
| Free Space | 空闲空间       | 不确定    | 页中尚未使用的空间              |
| Page Directory | 页面目录       | 不确定    | 页中的某些记录的相对位置              |
| File Trailer | 文件尾部       | 8字节    | 校验页是否完整              |

## 记录在页中的存储
- 用户存储的记录会按照指定的行格式存储到 `User Records` 部分

比较重要的记录头信息

### `delete_mask` 记录被删除后并不会马上从磁盘中删除
- 假如马上移除记录，那么其它的记录在磁盘上重新排列需要性能消耗，所以会打上一个删除标记
- 所有被删除的记录都会组成一个所谓的`垃圾链表`, 占用的空间称为 `可重用空间`
- 有新的记录插入到表中的话，可能会把这些被删除的记录占用的存储控件覆盖掉
- 将 `delete_mask` 位设置为1和将被删除的记录加入到垃圾链表中是2个阶段

### `heap_no`
- 表示当前记录在本页中的位置
- `InnoDB` 会自动插入两条规定的伪记录，分别是最小好最大记录。构造都是由5个字节大小的`记录头信息`和8字节大小的固定单词组成, 也就是 `Infimum + Supremum` 部分
- 最大最小记录的值分别为 0 和 1 ，也就是最靠前的

### `n_owned`
详细参见下文的 `Page Directory` 部分
每个组的最后一条记录会记录该组拥有多少记录

### `next_record`
- 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量(这个地址也就是说，左边是下一条记录的头信息，右边就是真实数据)
- 所以是链表中指向下一条记录的位置
- 下一条记录并不是`插入顺序`的下一条记录，而是`主键值从小到大排序`的下一条记录
- `Infimum记录（最小记录）`的下一条记就是本页中主键值最小的用户记录
- 本页中主键值最大的用户记录的下一条记录就是`Supremum记录(最大记录)`
- 所以`最小和最大记录`就是一页数据的链表的起始和结尾2个端点

## Page Directory 页目录
### 页目录的形成
- 将所有正常的记录（包括最大和最小记录，不包括标记为删除的记录）划分为几个组。
- 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的`n_owned`属性表示该记录拥有多少条
- 将每个组的最后一条记录的地址偏移量(真实地址偏移量)单独提取出来按顺序存储到靠近`页`的尾部的地方，也就是 `Page Directory`了
- 页面目录中的这些地址偏移量被称为`槽`(Slot)，所以页面目录就是`槽`构成的

### 页目录的规定
- 对于最小记录所在的分组只能有1条记录
- 最大记录所在的分组拥有的记录条数只能在 1 ~ 8 条之间
- 剩下的分组中记录的条数范围只能是4 ~ 8 之间

### 分组的步骤
- 初始情况下一个数据页只有最小记录和最大记录两条记录，它们属于两个分组
- 之后每插入一条记录，都会从 `页目录`中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的`n_owned`值加1，表示本组内又添加了一条记录，直到改组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分为两个组。一个组中4条记录，另一个5条记录。这个过程会在`页目录`中新增一个`槽`来记录这个新增分组中最大的那条记录。

### 页目录的作用
可以帮助查询语句的进行
- 当有一个主键时，会根据`二分法`找到确定该记录所在的槽
- 找到槽后，根据记录的 `next_record` 属性值遍历该槽所在的组中的各个记录

## Page Header(页面头部)

专门用于存储一个数据页中存储的记录的状态信息

| 名称              | 占用空间大小(字节) | 描述                                                         |
| ----------------- | ------------------ | ------------------------------------------------------------ |
| PAGE_N_DIR_SLOTS  | 2                  | 页目录中的槽数量                                             |
| PAGE_HEAP_TOP     | 2                  | 还未使用的空间的最小地址,也就是该地址之后就是 `Free Space`   |
| PAGE_N_HEAP       | 2                  | 本页中记录的数量(包括最大最小以及被标记为删除的记录)         |
| PAGE_FREE         | 2                  | 第一个已经标记为删除的记录地址（各个已删除的记录通过`next_record`也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| PAGE_GARBAGE      | 2                  | 已删除记录占用的字节数                                       |
| PAGE_LAST_INSERT  | 2                  | 最后插入记录的位置                                           |
| PAGE_DIRECTION    | 2                  | 记录插入的方向                                               |
| PAGE_N_DIRECTION  | 2                  | 一个方向连续插入的记录数量                                   |
| PAGE_N_RECS       | 2                  | 该页中记录的数量(不包括最小和最大记录以及被标记为删除的记录) |
| PAGE_MAX_TRX_ID   | 8                  | 修改当前页的最大事务ID,该值仅在二级索引中定义                |
| PAGE_LEVEL        | 2                  | 当前页在B+树中所处的层级                                     |
| PAGE_INDEX_ID     | 8                  | 索引ID,表示当前页属于哪个索引                                |
| PAGE_BTR_SEG_LEAF | 10                 | B+树叶子段的头部信息，仅在B+树的Root页定义                   |
| PAGE_BTR_SEG_TOP  | 10                 | B+树非叶子段的头部信息，仅在B+树的Root页定义                 |
|                   |                    |                                                              |


### `PAGE_DIRECTION`
- 假如新插入的一条记录比上一条记录的主键值大，那么这条记录的插入方向称为右边,反之则是左边
- 这个是指最后一条记录的插入方向

### `PAGE_N_DIRECTION`
- 假设连续插入新记录的方向都是一致的，`InooDB`会把沿着同一个方向插入记录的条数记下来，这个数值就用该字段表示
- 如果最后一条记录的插入方向改变了，那么这个状态的值就会清零重新统计

## File Header (文件头部)
- `Page Header` 是专门针对 `数据页`记录的各种状态信息
- `File HEader` 通用于各种类型的页，描述了一些通用的信息
- 这个部分占用固定的38个字节

| 名称                             | 占用空间大小 | 描述                                                         |
| -------------------------------- | ------------ | ------------------------------------------------------------ |
| FTL_PAGE_SPACE_OR_CHKSUM         | 4            | 页的校验和(checksum)值                                       |
| FTL_PAGE_OFFSET                  | 4            | 页号                                                         |
| FTL_PAGE_PREV                    | 4            | 上一个页的页号                                               |
| FTL_PAGE_NEXT                    | 4            | 下一个页的页号                                               |
| FTL_PAGE_LSN                     | 8            | 页面被最后修改时对应的日志序列位置(Log Sequence Number)      |
| FTL_PAGE_TYPE                    | 2            | 该页的类型                                                   |
| FTL_PAGE_FILE_FLUSH_LSN          | 8            | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| FTL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4            | 页属于哪个表空间                                             |

### FTL_PAGE_SPACE_OR_CHKSUM
- 代表当前页的 checksum
- 主要就是用于比较

### FTL_PAGE_OFFSET
- 每一个`页`都有一个单独的页号，`InnoDB`通过页号来唯一定位一`页`

### FTL_PAGE_TYPE
- 代表页的类型

| 类型名称                | 十六进制 | 描述                   |
| ----------------------- | -------- | ---------------------- |
| FTL_PAGE_TYPE_ALLOCATED | 0x0000   | 最新分配，还没使用     |
| FTL_PAGE_UNDO_LOG       | 0x0002   | Undo 日志页            |
| FTL_PAGE_INODE          | 0x0003   | 段信息节点             |
| FTL_PAGE_IBUF_FREE_LIST | 0x0004   | Insert Buffer空闲列表  |
| FTL_PAGE_IBUF_BITMAP    | 0x0005   | Insert Buffer 位图     |
| FTL_PAGE_TYPE_SYS       | 0x0006   | 系统页                 |
| FTL_PAGE_TYPE_TRX_SYS   | 0x0007   | 事务系统数据           |
| FTL_PAGE_TYPE_FSP_HDR   | 0x0008   | 表空间头部信息         |
| FTL_PAGE_TYPE_XDES      | 0x0009   | 拓展描述页             |
| FTL_PAHE_TYPE_BLOB      | 0x000A   | 溢出页                 |
| FTL_PAGE_INDEX          | 0x45BF   | 索引页，也就是`数据页` |


### FIL_PAGE_PREV 和 FIL_PAGE_NEXT
- `InnoDB` 以页为单位存放数据的，有时候存放数据的控件非常大，不可能一次性分配那么大的存储控件
-  `FTL_PAGE_PREV` 和 `FTL_PAGE_NEXT` 就代表本页的上一个和下一个的页号，这样就建立了一个双向链表把页连接在一起了
-  并不是所有页都有上一个和下一个的属性
-  `数据页`是有该属性的

## File Trailer
- `InnoDB` 会以`页`为单位将数据从磁盘上加载到内存中
- 如果数据被修改了，那么需要在修改后的某个时间将数据`同步`到磁盘中，但是由于各种不可抗力，这个同步是有可能中断的
- `File Trailer` 由于校验页是否完整，由 8 个字节组成
- 前4个字节代表页页的校验和
该值和 `File Header` 中的 `FTL_PAGE_SPACE_OR_CHKSUM` 属性相对应
当页在内存中被修改了，那么同步前就会算出`校验和`。
因为 `File Header` 在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部
假如完全同步成功，那么首部和尾部的`校验和`应该是一致的
如果不一致，那么数据就出了问题

- 后4个字节代表页面被最后修改时对应的日志序列位置(LSN)

该属性为所有类型的页通用的