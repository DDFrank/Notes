== 队列同步器 (AbstractQueuedSynchronizer)

用来构建锁或者其他同步组件的基础框架, 它使用了一个 int 成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作

=== 使用方式

使用的主要方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态

=== 实现方式

==== 同步队列

* 同步器依赖内部的同步队列 (FIFO 双向队列) 来完成同步状态的管理

* 当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造为一个节点 (Node) 并将其加入同步队列, 同时会阻塞当前线程

* 当同步状态释放的时候，会把首节点中的线程唤醒，使其再次尝试获取同步状态

* 同步队列中的节点 (Node) 用来保存 获取同步状态失败的线程的引用，等待状态和前后节点的引用

* AQS 持有 首节点 和 尾节点 的引用，以此来维持链表结构

* 首节点是获取同步状态成功的节点，首节点在释放同步状态时，将会唤醒后节点，后节点则会尝试获取同步状态并将自己设置为首节点

* 设置首节点的是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此一般都不需要通过 CAS 来设置首节点


==== 独占式的获取同步状态的流程

主要是 *acquire()* 方法

* 调用交给子类实现的 *tryAcquire()* 方法, 尝试去获取同步状态

* 如果获取失败，那么会通过 *addWaiter()* 方法构造一个新节点并加入到队列的尾部

* 最后调用 *acquireQueued()* 方法，使得该节点尝试自旋获取同步状态 （最多自旋几次后就将线程挂起等待唤醒）

* 当获取了同步状态的节点执行完逻辑需要释放同步状态时，调用 *release()* 方法，该方法释放了同步状态后，会唤醒其后继节点

==== 共享式的获取同步状态的流程

共享式和独占式的最大区别是同一时刻是否有多个线程可以获取同步状态

主要是 *acquireShared()* 方法

* 跟独占式的差不多，需要查看具体源码的差别

==== 独占式超时获取同步状态

主要是 *doAcquireNanos()* 方法

* 获取同步状态的代码跟独占式的差不多

* 再获取失败时，会判断是否已经超时

