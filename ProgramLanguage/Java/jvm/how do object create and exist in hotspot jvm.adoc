以下讨论仅限于hotSpot 虚拟机

== 对象的创建

* 虚拟机遇到 new 指令时, 会检查是否可以创建对象

** 检查这个指令的参数是否能在常量池中定位到一个类的符号引用

** 检查该符号引用代表的类是否已经被加载，解析和初始化过，如果没有，那就会执行类的加载过程

* 虚拟机为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。分配内存有两种算法

** 假如内存堆是绝对规整的，那么就可以使用指针碰撞 (Bump the Pointer， 有一个指针来标识可用和被占用对象的临界点)

** 假如内存堆不是规整的，必须维护一个空闲列表(Free List, 记录哪些内存块是可以用的)

** 堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定

* 需要考虑并发情况下的线程安全问题

** 对分配内存空间的动作进行同步处理(CAS, 失败重试)

** 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程都在 java 堆中预先分配一小块内存，称为本地线程分配缓冲，称为 TLAB(Thread Local Allocation Buffer)。该策略可由参数 -XX:+/-UseTLAB 决定是否开启，开启该功能后，哪个线程需要分配内存，就先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定

* 内存分配完之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）

** 使用 TLAB的话，也可以提前到 TLAB 分配时进行

** 该操作保证了在 java 代码中可以不赋初始值就直接使用(也就是使用零值)

* 虚拟机对对象进行必要的设置

** 对象是哪个类的实例

** 如何才能找到类的的元信息之类

** 这些信息存在对象的对象头中 (Object Header) 中

* 执行完 new 之后就会执行 <init> 方法，按程序员的意愿对对象进行初始化

== 对象的内存布局

主要分为三块区域

=== 对象头 (Header)

* 第一部分用于存储对象自身的运行时数据，比如哈希码，GC分代年龄，锁状态标志，线程持有的锁等等

** 在长度为 32 和 64 bit 的虚拟机中分别为 32bit 和 64 bit，称为 Mark Word

** 运行时的数据信息很多，其实已经超出了 32 和 64 位的 bitmap,

** 对象头信息是与对象自身定义的数据无关的额外存储成本，所以是一个非固定的结构。

** 会根据对象的状态复用自己的存储空间


.Table: HotSpot虚拟机对象头Mark Word
|===
|存储内容|标志位|状态
|对象哈希码，对象分代年龄|01|未锁定
|指向锁记录的指针|00|轻量级锁定
|指向重量级锁的指针|10|膨胀(重量级锁定)
|空，不需要记录信息|11|GC标记
|偏向线程ID，偏向时间戳,对象分代年龄|01|可偏向
|===


* 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例

** 不是所有虚拟机实现都必须在对象数据上保留类型指针，即，查找对象的元信息不一定要经过对象本身

** 假如是数组，那么还必须有一块用于记录数组长度的数据

=== 实例数据(Instance Data)

* 对象真正存储的有效信息,无论是父类继承下来的还是在子类中定义的都需要记录起来

* 这部分的存储顺序会受到虚拟机分配策略参数(-XX: FieldsAllocationStyle)和字段在 java 源码中定义顺序的影响

* HotSpot虚拟机默认的分配顺序为longs/doubles, ints, shorts/chars, oops(Ordinary Object Pointers, OOPS)。相同宽度的字段总是被分配到一起存放,然后父类中的变量会出现在子类之前 

=== 对齐填充(Padding)

* 不是必然存在的， 仅仅是占位符

* 自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以需要补齐

== 对象的访问定位

* Java程序会通过栈上的reference数据来操作堆上的具体对象

* reference 类型具体是怎么实现并未规定，主流的方式有`句柄`和`直接指针`两种

=== 句柄访问

* 堆中将会划分出一块内存作为句柄池， reference 中存储的就是对象的句柄地址

* 句柄中包含了对象实例数据和类型数据各自的具体地址信息

=== 直接指针访问

* reference 中存储的直接就是对象地址

* 堆对象的布局必须考虑如何放置访问类型数据

=== 两种访问方式的比较

* 句柄访问的最大好处是 reference 中存储的是稳定的句柄地址，对象被移动时只需要改变句柄中的实例数据指针，而不用改变 reference 的值

* 直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销（也就是实例类型数据不需要指针去定位了）