

## 基本用法

### 定义结构体

```go
type 类型名 struct {
	字段1 类型
  字段2 类型
}
```

- 同类型的变量可以写在一行

### 实例化结构体

```go
type Point struct {
  X int
  Y int
}

var p Point
p.X = 10
p.Y = 20
```

#### 创建指针类型的结构体

```go
// T 为类型
// ins: 类型为 *T, 属于指针
ins := new(T)
```

```go
type Player struct {
  Name string
  Health Point int
  Magic Point int
}

tank := new(Player)
// 即使是结构体指针，也可以通过 . 来访问
// 实际上是 (*tank).Name 的语法糖
tank.Name = "Canon"
```

#### 取结构体的地址实例化

```go
// 对结构体进行 & 取地址操作时，视为对该类型进行一次 new的实例化操作
ins := &T{}
```



### 初始化结构体的成员变量

#### 键值对

适合选择性填充字段值较多的结构体

```go
ins := 结构体类型名{
  // 初始化可选
  字段1: 值
  字段2: 值
}
```

#### 多个值的列表

```go
// 必须初始化所有字段
// 顺序必须一致
ins := 结构体类型名{
	字段1的值,
  字段2的值
}
```



### 匿名结构体

```go
ins := struct {
 // 字段定义
} {
  // 字段值初始化
}
```



### 方法

```go
type Bag struct {
 	items []int 
}
// 表示接收器
func (b *Bag) Insert(itemid int) {
  b.items = append(b.items, itemid)
}

func main() {
  b := new(Bag)
  b.Insert(1001)
}
```

### 值方法和指针方法的区别

- 值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型

  指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上

- 

### 结构体内嵌

#### 类型内嵌

结构体允许其成员字段在声明时没有字段名而只有类型

```go
type Data struct {
  int
  float32
  bool
}
// 类型内嵌的字段名就是类型本身，因此必须唯一
ins := &Data{
  int: 10,
  float32: 3.14,
  bool: true,
}
```

#### 内嵌结构体

结构体实例化之后，如果匿名的字段为结构体，那么可以直接访问匿名结构体里的所有成员

- 内嵌的结构体可以直接访问其成员变量
- 内嵌结构体的字段名是它的类型名
- 一个结构体只能嵌入一个同类型的成员,假如出现歧义编译器会报错
- 被嵌入的结构体的和嵌入的结构体的方法如果重名，那会嵌入的结构体的方法会被屏蔽掉

