## 通道

### 声明通道类型并初始化

```go
var 通道变量 chan 通道类型
// 创建通道
// 非缓冲通道仅在发送方和接收方都就绪的时候才会传输数据,因为数据无法缓存
通道实例 := make(chan 数据类型)
```

### 发送数据

```go
// 创建空接口通道
ch := make(chan interface{})
// 将0放入
ch <- 0
```

发送数据时，假如接收方一直都没有接收，那么发送操作就持续阻塞

### 接收数据

#### 基本规则

- 通道的收发操作在不同的两个goroutine间进行
- 接收将持续阻塞直到发送方发送数据
- 每次接受一个元素

#### 接收的写法

- 阻塞接收数据

```go
data := <- ch
```

- 非阻塞接收数据

```go
// ok 表示十分收到了数据，没收到时 data为零值
data,ok := <- ch
// 该方法可能造成极高的cpu占用，使用比较少
```

- 接收任意数据，忽略接收的数据

```go
// 阻塞接到数据，但是会忽略从通道返回的数据
<-ch
```

- 循环接收

```go
for data := range ch {
  ...
}
```



### 单向通道

通道可以在声明时约束其操作方向，只发送或只接收

#### 格式

```go
// 只能发送
var 通道实例 chan <- 元素类型
// 只能接收通道
var 通道实例 <- chan 元素类型
```



### 带缓冲的通道

可以为通道增加一个缓冲区

- 发送时无需等待接收方接收，且只有在存储空间满时才会阻塞
- 通道有数据时，读取不会阻塞，没有数据读时会阻塞

#### 创建

```go
// 缓存大小是可以保存多少个数据
通道实例 := make(chan通道类型，缓冲大小)
```



### 通道的多路复用

select 关键字可以同时响应多个通道的操作

```go
// 操作是指通道收发语句
// 响应操作时完成后的操作
select {
  case 操作1:
  	响应操作1
  case 操作2:
  	响应操作2
  ...
  default:
  	....
}
```

- 如果有默认分支，那么会在没有任何通道有数据的情况下选中默认分支
- 如果没有默认分支，并且没有通道有数据到达，那么select块就会阻塞直到数据到达
- select 语句一次只能求值一次
- 可以使用 break 跳出 select

### 关闭

通道可以关闭，给已关闭的通道发送数据会panic

从已关闭的通道接收数据会接收到零值且不会阻塞