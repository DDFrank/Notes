# SQL 反模式笔记

## 需要列表字段时

- 通常是为了多对多的关系存储

- 使用 某个符号来分割字符串是一个糟糕的做法，除非系统及其简便而且该字段不需要查询
- 建新的表是比较好的做法

## 主键

- 笼统的规定每个表都有一个主键不是一个好办法
- 有的表其实是需要联合主键的
- 主键统一叫 id 也不是必须要遵守的

## 对于树形结构的存储办法

- 邻接表 : 自连接那种
- 枚举路径: 搞个字段记录节点的路径
- 嵌套集: 搞两个字段，深度遍历树来记录，查询很方便，插入删除更新都很麻烦
- 闭包法 : 专门用另外一张表来记录外键关系, 增删改查都方便，就是占空间

## 不使用外键

- 其实是不好的，也不会非常节省效率

## 实体-属性-值 EAV模式

- 就是搞一个表， 以键值对的形式存储 不同的属性， 有如下缺点
  - 不方便查询，查询必须联表并关联字段的值
  - 每个属性对应 属性表的一行，而不是一列, 无法使用列的约束
  - 因为没有列，所以无法使用SQL的数据类型

- 当有需求要动态添加元数据的时候，用nosql的数据库是比较好的
- 当子类型数量有限时，也有一些解决方案
  - 单表继承：
    - 将所有相关的类型都存在一张表中，为所有类型的所有属性都保留一列
    - 使用一个属性来定义每一行表示的子类型
    - 适用于数据的子类型比较少，以及子类型特殊属性比较少的情况
  - 实体表继承:
    - 为每个子类型创建一张独立的表，
    - 每个表包含那些属于基类的共有属性，同时也包含子类型特殊化的属性
    - 可以避免存储一些无用的属性, 也不用搞一个字段来标名类型
    - 当很少需要一次性查询所有子类型时，这种方法比较好
  - 类表继承
    - 模拟了继承，把表当成面向对象里的类
    - 创建一个基类表，包含所有子类型的公共属性
    - 对于每个子类型，创建一个独立的表，通过外键和基类表相连
    - 经常要查询所有子类型时该方法比较好
  - 使用 xml 或 json 结构的数据
    - 缺点就是基本无法查询

## 多态关联

- 当 一个表需要引用多个互斥的表的主键作为外键时，将该表的外键定义去掉，作为事实上的外键
- 同时再多加一个字段表明引用的是哪一个表
- 通常使用这种方式后就得依赖上层代码来保证数据完整性了。
- 交叉表: 为每一个父表(一对多的一那一方) 建立一个交叉表,来存储外键关联关系
- 创建共用的超级表: 专门创建一个表来存储外键关系，然后在将这张表的外键关系分配给子类型表

## 多列属性

- 在一个表中添加一些表示属性的列，比如 tag1 tag2 tag3 
- 看上去就很不好,缺点很多
- 这个通常是解决 一对多的属性的需求，解决方案:
  - 创建从属表，用一列来存储多值属性
  - 将多个值存在多行而不是多列当中。
  - 在从属表中定义一个外键，将这个值和bugs表中的主记录关联起来

## 元数据分裂

- 当一张表的数据量变得非常巨大外，除了手动拆分这张表，更好的做法是水平分区，垂直分区以及使用关联表

### 使用水平分区

- 水平分区或者分片，也就是俗称的分表
- 也就是根据行来对表进行拆分

### 使用垂直分区

- 根据列来对表进行拆分。
- 当某些列非常庞大或者很少使用的时候，对表进行按列拆分会比较有优势

### 创建关联表

- 不要让数据去繁衍元数据

## 需要存储小数位的时候

- 使用 NUMERIC 或 DECIMAL 类型来代替 float 类型
- 前一个数字为总位数，后一个是是小数位

## 限定列的有效值

- 考虑到拓展性，不应该使用枚举等类型来约束一个列
- 创建另外一张表，来专门为该列提供一些值

## 大文件和图片的存储

- 作者觉得有时候应该将图片或者大文件存储在数据库中

## 正确使用索引

- 好的索引的建立需要反复测试

## NULL的使用

- 不要将NULL 当做一个普通值来处理
- 也不要用一个普通值来取代一个NULL的作用
- 使用 NULL 来表示任意类型的悬空值

## 关于 分组

## 获取随机记录

- 只要主键是从1到最大值连续的时候，可以从1到最大主键值之间随机选择一个
- 计算总的数据行数，然后随机获取某些行

## 全文检索

- 交给 nosql 把

## 复杂的查询

- 面对复杂的查询时，尽量不要想着用一个sql搞定
- 该实验 UNION ALL 的时候就用
- 可以考虑自动生成SQL语句来解决问题