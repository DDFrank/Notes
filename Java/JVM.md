# Java 内存区域

## 运行时数据区域

### 程序计数器 (Program Counter Register) 

- 是一块较小的内存空间
- 可以看做是当前线程所执行的字节码的行号指示器
  - 在概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
  - 分支，循环，跳转，异常处理，线程恢复等功能都依赖于这个计数器完成、
- 多线程是通过线程轮流切换来实现的，所以任何一个确定的时刻，一个处理器都只会执行一条线程中的指令
- 因此，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的计数器
- 如果线程在 执行一个 Java方法，那么该计数器记录的是正在执行的虚拟机的字节码指令的地址
- 如果是 native 方法，则该 计数器值为空。此内存区域是唯一一个在 Java虚拟机规范中没有规定OOM的情况的区域

### Java 虚拟机栈 (Java Virtual Machine Stacks)

- 也是线程私有的
- 生命周期等同于线程
- 虚拟机栈描述的是 Java 方法执行的内存模型
- 每个方法在执行时都会创建一个栈帧 (Stack Frame) 用于存储局部变量表，操作数栈，动态链接，方法出口等信息
- 每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
- 局部变量表存放了编译期可知的各种基本数据类型，对象引用和 returnAddress类型(指向了一条字节码指令的地址)
- 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间 (Slot), 其余的都是1个
- 局部变量表所需的内存空间在编译期间完成分配，方法运行期间不会改变局部变量表的大小
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常
- 如果虚拟机可以动态拓展，但是拓展时无法申请到足够的内存，就会抛出OOM

### 本地方法栈 (Native Method Stack)

- 与虚拟机栈类似，不过是执行 native 方法
- 也会抛出 StackOverflow 和 OOM

### Java 堆 (Java Heap)

- 虚拟机管理内存最大的一块
- 被所有线程共享
- 在虚拟机创建时启动，唯一目的就是存放对象实例
- 是 GC的主要区域
- 在物理上可以不连续，只要逻辑上是连续的即可
- 无法拓展时抛出 OOM

### 方法区 (Method Area)

- 同样是各个内存共享的内存区域
- 用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后后的代码等数据
- 该区域的内存回收主要是针对常量池的回收和对类型的卸载
- 会抛出 OOM

### 运行时常量池 (Runtime Constant Pool)

- 是方法区的一部分
- Class 文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池
- 用于存放编译期生成的各种字面量和符合引用，这部分内容将在类加载后进入方法区的运行时常量池中存放
- 运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性，运行期间也可能将新的常量池放入池中

### 直接内存

- 并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域
- JDK 的 NIO API 中引入了一种基于通道 (Channel) 与缓冲区 (Buffer) 的 I/O 方式，可以使用 native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作
- 受本机总内存大小的影响也会OOM

## 虚拟机对象

### 对象的创建

- 虚拟机遇到 new 指令时
  - 检查这个指令的参数是否能在常量池中定位到一个类的符号引用
  - 检查该符号引用代表的类是否已经被加载，解析和初始化过，如果没有，那就会执行类的加载过程
- 虚拟机为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。分配内存有两种算法
  - 假如内存堆是绝对规整的，那么就可以使用指针碰撞 (Bump the Pointer)
  - 假如内存堆不是规整的，必须维护一个空闲列表(Free List)
  - 堆是否规整由所采用的垃圾收集器是否带有压缩整理功能绝对
- 需要考虑并发情况下的线程安全问题
  - 对分配内存空间的动作进行同步处理(CAS 和 失败重试)
  - 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程都在 java 堆中预先分配一小块内存，称为本地线程分配缓冲，称为 TLAB(Thread Local Allocation Buffer)。该策略可由参数 -XX:+/-UseTLAB 决定是否开启
- 内存分配完之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）
  - 使用 TLAB的话，也可以提前到 TLAB 分配时进行
  - 该操作保证了在 java 代码中可以不赋初始值就直接使用(也就是使用零值)
- 虚拟机对对象进行必要的设置
  - 对象是哪个类的实例
  - 如何才能找到类的的元信息之类
  - 这些信息存在对象的对象头中 (Object Header) 中
- 执行完 new 之后就会执行 <init> 方法，按程序员的意愿对对象进行初始化

### 对象的内存布局

可以分为三块区域

#### 对象头 (Header)

- 第一部分用于存储对象自身的运行时数据，比如哈希码，GC分代年龄，线程持有的锁等
  - 在长度为 32 和 64 bit 的虚拟机中分别为 32bit 和 64 bit，称为 Mark Word
  - 运行时的数据信息很多，其实已经超出了 32 和 64 位的 bitmap,
  - 对象头信息是与对象自身定义的数据无关的额外存储成本，所以是一个非固定的结构。
  - 会根据对象的状态复用自己的存储空间
- 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例
  - 不是所有虚拟机实现都必须在对象数据上保留类型指针，即，查找对象的元信息不一定要经过对象本身
  - 假如是数组，那么还必须有一块用于记录数组长度的数据

#### 实例数据(Instance Data)

- 对象真正存储的有效信息
- 无论是父类继承下来的还是在子类中定义的都需要记录起来
- 这部分的存储顺序会受到虚拟机分配策略参数和字段在 java 源码中定义顺序的影响

#### 对齐填充(Padding)

- 不是必然存在的， 仅仅是占位符
- 自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以需要补齐

### 对象的访问定位

主流的通过 栈上的引用去访问堆的方式有两种

#### 句柄访问

- 堆中将会划分出一块内存作为句柄池， reference 中存储的就是对象的句柄地址
- 句柄中包含了对象实例数据和类型数据各自的具体地址信息

#### 直接指针访问

- 堆对象的布局必须考虑如何放置访问类型数据
- reference 中存储的直接就是对象地址

### 比较

- 句柄访问的最大好处是 reference 中存储的是稳定的句柄地址，对象被移动时只需要改变句柄中的实例数据指针，而不用改变 reference 的值
- 直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销（也就是实例类型数据不需要指针去定位了）

###  OOM 实战

- TODO 待补完

# 垃圾收集器与内存分配策略

## 如何判断对象可以被回收

### 引用计数算法

- 有一个地方引用时，加 1 ，当引用失效时， -1 ,为 0时说明可以被回收
- 该算法无法解决循环引用的问题，比如 A.a = B.b A.b = B.a 之类的

### 可达性分析算法

- 通过一系列的 GC Roots 的对象作为起始点，从这些节点开始往下搜索，搜索走过的路径称为引用链
- 当一个对象到 GC Roots 没有任何引用链相连的话，则此对象是不可用的
- Java 中，可作为 GC Roots 的对象有以下几种
  - 虚拟机栈(栈帧中的本地变量表)中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
  - 本地方法栈中JNI（即 Native方法）引用的对象

### Java 中的引用

分为4种

#### 强引用 

- 通过 new 关键字出来的，只要存在就不会被回收

#### 软引用

- 用于描述一些还有用但并非必需的对象
- 在系统即将发生内存溢出的时候，将会把这些对象列进回收范围中进行第二次回收，假如还不行就会抛出异常 
- 使用 SoftReference 类来实现

#### 弱引用

- 也是用来描述非必需的对象的,比软引用更弱
- 被关联的对象只能活到下一次垃圾收集之前
- 使用 WeakReference 类来实现

#### 虚引用

- 最弱的，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响
- 无法通过虚引用来取得一个对象实例
- 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知
- 通过 PhantomReference 类来实现

### 对象的生存和死亡

- 对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那么它将会被第一次标记并且进行一次筛选
- 筛选的条件是此对象是否有必要执行 finalize() 方法。
  - 对象没有重写 finalize() 方法，没必要
  - 对象的 finalize() 方法已经被虚拟机调用过，没必要
- 假如有必要的话，会将对象放入一个 F-Queue 的队列中稍后由一个由虚拟机自动建立的，低优先级的 Finalizer 线程去执行
- 不要使用 finalize() 方法

### 回收方法区

主要是两部分

#### 废弃常量

- 没有引用就会被清除出常量池

#### 无用的类

- 该类的所有实例都已经被回收，java堆中不存在该类的任何实例
- 加载该类的 Classloader 已经被回收
- 该类对应的 java.lang.Class 对象没有在任何地方呗引用，无法在任何地方通过反射访问该类的方法
- 虚拟机可以对满足上述条件的无用类进行回收，注意并不是必须
- 可以对虚拟机提供参数来控制上述行为

## 垃圾回收算法

### 标记-清除算法(Mark-Sweep) 算法

- 首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象
- 效率不高，标记和清除的效率都不高
- 标记清除后会产生大量不连续的内存碎片，导致无法找到足够的连续内存时需要提前触发一次垃圾收集动作

### 复制算法

- 将可用的内存按照容量划分为大小相等的两块，每次只用一块
- 当这一块的内存用完了，就将还存活的着的对象复制到另一块上去，再去清理已经使用过的内存空间
- 将内存缩小了一半，代价太高
- 目前的商业虚拟机都依靠复制算法来回收新生代
  - 由于新生代的对象交替很快，所以会将内存分为一块较大的 Eden 空间 和 两块较小的 Survivor 空间
  - 首先使用一块 Eden 空间和一块 Survivor 空间
  - 回收时，将 Eden 和 使用的 Survivor 中存活的对象都复制到 另一块 Survivor 中，再清理
  - 另一块 Survivor 中内存不足时会依赖 老年代进行分配担保

### 标记-整理算法(Mark-Compact)

- 过程跟 标记-清除一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动
- 然后直接清理掉端边界外的内存
- 多用于老年代

### 分代收集算法(Generational Collection)

- 当前主流的虚拟机都采用该算法
- 根据对象存活周期的不同将内存划分为几块(老年代，新生代),然后各自使用不同的算法。

## 算法实现

看不懂，放弃

## 垃圾收集器

略

### 如何理解GC日志

TODO 待补完

### 内存分配和回收策略

TODO 待补完

# 虚拟机性能监控与故障处理工具

## jps

-  虚拟机进程状况工具 (JVM Process Status Tool)
- 可以列出正在运行的虚拟机进程
- 可以显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID(Local Virtual Machine Identifier, LVMID)
- 其它工具经常需要使用该工具查询 LIMID 作为输入

### 执行格式

jps [ options ] [ hostid ]

### 主要选项

- -q : 只输出 LVMID，省略主类的名称
- -m: 输出虚拟机进程启动时 传递给主类 main() 函数的参数
- -l : 输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径
- -v : 输出虚拟机进程启动时 JVM 参数



## jstat

- JVM Statistics Monitoring Tool: 用于监视虚拟机各种运行状态信息的命令行工具
- 可以显示本地或者远程（需要RMI支持）虚拟机进程中的类装载，内存，垃圾收集，JIT编译等运行数据
- 在无法图形化的服务器上可以用来定位虚拟机性能问题

### 执行格式

jstat [ option vmid [interval [s|ms ] [count] ] ]

- 参数 interval 和 count 代表查询间隔和次数，如果省略，说明只查询一次
- option 代表用户希望查询的虚拟机信息，主要由类装载，垃圾收集，运行期编译状况
  - -class: 监视类装载，卸载数量，总空间以及类装载所耗费的时间
  - -gc : 监视 Java 堆状况，包括 Eden 区，两个 survivor 区，老年代，永久代等的容量，已用空间，GC时间合计等
  - -gccapacity: 与 -gc基本相同，但输出主要关注 Java 堆各个区域使用的最大，最小空间
  - -gcutil: 监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比
  - -gccause: 与 -gcutil 功能一样，但是会额外输出导致上一次GC产生的原因
  - -gcnew: 监视新生代GC状况
  - -gcnewcapacity: 与 -gcnew 基本相同，输出主要关注使用到的最大，最小空间
  - -gcold: 监视老年代GC状况
  - -gcoldcapacity: 监视内容与 -gcold 基本相同，输出主要关注使用到的最大，最小空间
  - -gcpermcapacity: 输出永久代使用到的最大，最小空间
  - -compiler: 输出JIT编译器编译过的方法，耗时等信息
  - -printcompilation: 输出已经被 JIT 编译的方法

## jinfo

- 实时查看和调整虚拟机各项参数

### 格式

```shell
jinfo [option] pid
```

- -flag 查看指定参数的默认值

## jmap

- 用于生成堆转储快照(heapdump 或 dump 文件)
- 也有别的方式可以获取 dump 文件
  -  -XX + HeapDumpOnOutOfMemoryError 参数
- 除了获取dump文件，还可以获取更多信息

### 格式

```shell
jmap [option] vmid
```

- -dump: 生成 java 堆转储快照。格式为: -dump[live, ] format = b, file = <filename>, 其中live 参数说明是否只 dump 出存活的对象
- -finalizerinfo: 显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象
- -heap : 显示 Java 堆详细信息，如使用哪种回收器，参数配置，分代状况等
- -histo: 显示堆中对象统计信息，包括类，实例数量，合计容量
- -permstat: 以 ClassLoader 为统计口径显示永久代内存状态。
- -F : 当虚拟机进程对 -dump 没有选项时，可以用这个强制生成



## jhat

- 可以跟 jmap 搭配使用，分析 dump 文件
- 比较不好用

## jstack

- 用于生成虚拟机当前时刻的线程快照（threaddump 和 javacore 文件）
- 主要用来定位线程出现长时间停顿的原因
- Thread 类中有一个 getAllStackTraces 的方法用于获取虚拟机所有线程的堆栈信息，可以用来做监控工具

### 格式

```shell
jstack [option] vmid
```

- -F 当正常输出的请求不被响应时，可强制输出线程堆栈
- -l  除堆栈外，显示关于锁的附加信息
- -m 如果调用到本地方法的话，可以显示 c/c++ 的堆栈



## HSDIS

- 好像跟汇编什么的有关，不知道是干什么用的

## JConsole

- 基于 JMX 的可视化监视，管理工具

## VisualVM

- 多合一故障处理工具



# 类文件结构

## Class 类文件的结构

- Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，中间没有任何分隔符
- 当遇到需要占用 8 位字节以上数据项时，会按照高位在前的方式分割成若干 8 位字节进行存储
- Class 文件中只有两种结构，无符号数和表
  - 无符号数是基本的数据类型，u1 , u2 ,u4, u8 分别代表1个字节，2个字节，4个字节和8个字节的无符号数
    - 无符号数可以描述 数字，索引引用，数量值或者按照 UTF-8 编码构成字符串值
  - 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以 _info 结尾
    - 表用于描述有层次关系的复合数据结构
- 整个Class 文件本质上就是一张表

| 类型           | 名称                | 数量                    |
| -------------- | ------------------- | ----------------------- |
| u4             | magic               | 1                       |
| u2             | minor_version       | 1                       |
| u2             | major_version       | 1                       |
| u2             | constant_pool_count | 1                       |
| cp_info        | constant_pool       | constant_pool_count - 1 |
| u2             | access_flags        | 1                       |
| u2             | this_class          | 1                       |
| u2             | super_class         | 1                       |
| u2             | interfaces_count    | 1                       |
| u2             | interfaces          | interfaces_count        |
| u2             | fields_count        | 1                       |
| field_info     | fields              | fields_count            |
| u2             | methods_count       | 1                       |
| method_info    | methods             | methods_count           |
| u2             | attributes_count    | 1                       |
| attribute_info | attributes          | attributes_count        |
|                |                     |                         |

### 魔数

- 头4个字节是魔数

### Class 文件的版本

- 魔数后面的4个字节存储的是 Class 文件的版本号
  - 5, 6 字节是次版本号
  - 7，8字节是主版本号

### 常量池

- Class 文件结构中与其它项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一
- 第一个出现的表类型
- 常量池的数量是不固定的，因此常量池的入口有一项 u2 类型的数据表示常量池的容量 (constant_pool_count)
- 容量计数是从1开始的, 0用来表示某些指向常量池的索引值的数据再特定情况下需要表达 "不引用任何一个常量池项目"
- 常量池存放两大类常量
  - 字面量(Literal): 比如 文本字符串，final的常量值等
  - 符号引用(Symbolic References):
    - 类和接口的全限定名
    - 字段的名称和描述符
    - 方法的名称和描述符
- Java 的代码在编译时，是在虚拟机加载 Class 文件的时候进行动态连接。虚拟机运行时，需要从常量池中获得对应符号的引用，再在类创建时或运行时解析，翻译到具体的内存地址之中
- 常量池中每一项都是一个表, 每张表的第一位都是一个 u1 类型的标志位(tag), 代表是什么类型

| 类型                             | 标志 | 描述                     |
| -------------------------------- | ---- | ------------------------ |
| CONSTANT_Utf8_info               | 1    | UTF8编码的字符串         |
| CONSTANT_Integer_info            | 3    | 整型字面量               |
| CONSTANT_Float_info              | 4    | 浮点型字面量             |
| CONSTANT_Long_info               | 5    | 长整型字面量             |
| CONSTANT_Double_info             | 6    | 双精度浮点型字面量       |
| CONSTANT_Class_info              | 7    | 类或接口的符号引用       |
| CONSTANT_String_info             | 8    | 字符串类型字面量         |
| CONSTANT_Fieldref_info           | 9    | 字段的符号引用           |
| CONSTANT_Methodref_info          | 10   | 类中方法的符号引用       |
| CONSTANT_InterfaceMethodref_info | 11   | 接口中方法的符号引用     |
| CONSTANT_NameAndType_info        | 12   | 字段或方法的部分符号引用 |
| CONSTANT_MethodHandle_info       | 15   | 表示方法句柄             |
| CONSTANT_MethodType_info         | 16   | 标识方法类型             |
| CONSTANT_InvokeDynamic_info      | 18   | 表示一个动态方法调用     |

- 这些数据类型又各自有自己的数据类型

P170 页，补完数据类型表 TODO

- 可以使用 javap -verbose 参数输出 class 文件的字节码内容



### 访问标志

- 常量池之后的两个字节表示访问标志 (access_flags),
- 该标识用于识别一些类或者接口层次的访问信息，比如是类还是接口，是否是 public 的

| 标志名称      | 标志值 | 含义                                                        |
| ------------- | ------ | ----------------------------------------------------------- |
| ACC_PUBLIC    | 0x0001 | 是否是public                                                |
| ACC_FINAL     | 0x0010 | 是否是 final                                                |
| ACC_SUPER     | 0x0020 | 是否允许使用 invokespecial 字节码的新语意， 1.02 之后都为真 |
| ACC_INTERFACE | 0x0200 | 标识是一个接口                                              |
| ACC_ABSTRACT  | 0x0400 | 是否为 abstract                                             |
| ACC_SYNTHETIC | 0x1000 | 标识这个类并非由用户代码产生的                              |
| ACC_ANNOTATIO | 0x2000 | 标识是一个注解                                              |
| ACC_ENUM      | 0x4000 | 标识是一个枚举                                              |
|               |        |                                                             |

- access_flags 中一共有 16 个标志位可用，当前只定义了其中 8个
- 没有用到的标志位一律为0



### 类索引，父类索引与接口索引集合

- 类索引 (this_class) 和 父类索引 (super_class) 都是一个 u2 类型的数据
- 接口索引集合 (interfaces) 是一组 u2 类型的数据的集合
-  Class 文件中由这三项数据来确定这个类的继承关系
- 类索引用于确定该类的全限定名
- 父类索引用于确定该类的父类的全限定名，除了 Object 外都有值
- 接口索引集合用来描述该类实现了哪些接口，被实现的接口按照声明顺序从左到右排列
- 都在访问标志之后
- 类和父类索引都有两个 u2 类型的索引值表示，各自指向一个类型为 CONSTANT_Class_info 的类描述符常量
- 接口索引集合入口的第一项 : u2 类型的数据为接口计数器,表示索引表的容量
  - 假如没实现接口，则接口计数器为0，后面的字节不再占用任何字节



### 字段表集合

- 字段表 (field_info) 用于描述接口或类中声明的变量。
- 包括 类级变量和实例级变量, 但不会包括局部变量
- 字段可以包括的修饰符有:
  - 作用域 (public, private, protected)
  - 是不是 static
  - 可变性 final
  - 并发可见性 volatile
  - 可否被序列化 transient
  - 字段数据类型 (基本类型，引用类型，数组)
  - 字段名称
- 上述信息中，修饰符等为布尔值的适合用标志位表示
- 而描述性信息的都是引用常量池中的常量来表示
- 字段表结构

| 类型           | 名称             | 数量             |
| -------------- | ---------------- | ---------------- |
| u2             | access_flags     | 1                |
| u2             | name_index       | 1                |
| u2             | descriptor_index | 1                |
| u2             | attributes_count | 1                |
| attribute_info | attributes       | attributes_count |
|                |                  |                  |

- 字段修饰符在 access_flags 项目中，是一个 u2 数据类型

| 标志名称      | 标志值 | 含义                       |
| ------------- | ------ | -------------------------- |
| ACC_PUBLIC    | 0x0001 |                            |
| ACC_PRIVATE   | 0x0002 |                            |
| ACC_PROTECTED | 0x0004 |                            |
| ACC_STATIC    | 0x0008 |                            |
| ACC_FINAL     | 0x0010 |                            |
| ACC_VOLATILE  | 0x0040 |                            |
| ACC_TRANSIENT | 0x0080 |                            |
| ACC_SYNTHETIC | 0x1000 | 字段是否有由编译器自动产生 |
| ACC_ENUM      | 0x4000 |                            |
|               |        |                            |

- name_index 和 descriptor_index 都是索引值，分别表示着字段的简单名称以及字段和方法的描述符
- 描述符的含义

| 标识字符 | 含义     |
| -------- | -------- |
| B        | byte     |
| C        | char     |
| D        | double   |
| F        | float    |
| I        | int      |
| J        | long     |
| S        | short    |
| Z        | boolean  |
| V        | void     |
| L        | 对象类型 |

- 对于数组类型，每一维度都有一个前置的 "[" 字符来描述，比如整数数组为 "[I"
- 对于方法，按照先参数列表，后返回值的方式描述
  - 参数列表按照参数的严格顺序放在一组小括号之内， void inc() 的描述符为 ()

- 字段表之后的 会有一个属性表来存储额外的信息，详见属性表
- 字段表中不会出现 父类或超类中继承的字段，但有可能会有原本代码中不存在的字段，比如内部类为了保持对外部类的访问性，会自动添加指向外部类实例的字段



### 方法表集合

- 对方法的描述和对字段的描述几乎一致
- 方法表的结果也是 访问标志，名称索引，描述符索引，属性表集合几项
- 访问标志

| 标志名称         | 标志值 | 含义                         |
| ---------------- | ------ | ---------------------------- |
| ACC_PUBLIC       | 0x0001 |                              |
| ACC_PRIVATE      | 0x0002 |                              |
| ACC_PROTECTED    | 0x0004 |                              |
| ACC_STATIC       | 0x0008 |                              |
| ACC_FINAL        | 0x0010 |                              |
| ACC_SYNCHRONIZED | 0x0020 |                              |
| ACC_BRIDGE       | 0x0040 | 是否是由编译器生成的桥接方法 |
| ACC_VARARGS      | 0x0080 | 方法是否接受不定参数         |
| ACC_NATIVE       | 0x0100 |                              |
| ACC_ABSTRACT     | 0x0400 |                              |
| ACC_STRICTFP     | 0x0800 | 是否为 strictfp              |
| ACC_SYNTHETIC    | 0x1000 | 是否是由编译器生成的         |
|                  |        |                              |

- 方法的代码编译为字节码之后放存放在方法属性表里一个名为 "Code" 的属性里面
- 父类的方法如果没被重写，就不会出现
- 有可能出现编译器自动添加的方法，比如 类构造器 <client> 或者 实例构造器 <init> 等



### 属性表集合

- 字段表和方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。
- 一些属性中的关键常用部分

| 属性名称                            | 使用位置           | 含义                                                         |
| ----------------------------------- | ------------------ | ------------------------------------------------------------ |
| Code                                | 方法表             | Java代码编译的字节码指令                                     |
| ConstantValue                       | 字段表             | final 关键字定义的常量值                                     |
| Deprecated                          | 类，方法表，字段表 | 被声明为 deprecated 的方法和字段                             |
| Exceptions                          | 方法表             | 方法抛出的异常                                               |
| EnclosingMethod                     | 类文件             | 仅当一个类为局部类或者匿名类时才有这个属性，这个属性用于标识这个类所在的外围方法 |
| InnerClass                          | 类文件             | 内部类列表                                                   |
| LineNumberTable                     | Code 属性          | Java 源码的行号与字节码指令的对应关系                        |
| LocalVariableTable                  | Code 属性          | 方法的局部变量描述                                           |
| StackMapTable                       | Code属性           | JDK1.6+, 供新的类型检查验证器(Type Checker) 检查和处理目标方法的局部变量和操作数栈所需要的类型是否匹配 |
| Signature                           | 类，方法表，字段表 | JDK1.5+, 用于支持泛型情况下的方法签名。任何泛型的数据类型都用该属性来记录泛型信息 |
| SourceFile                          | 类文件             | 记录源文件名称                                               |
| SourceDebugExtension                | 类文件             | JDK1.6+,用于存储额外的调试信息，为非Java 语言编写，却需要编译为字节码并运行在 虚拟机的程序提供了一个进行调试的标准机制 |
| Synthetic                           | 类，方法表，字段表 | 标识 方法或字段为编译器自动生成的                            |
| LocalVariableTypeTable              | 类                 | JDK1.5+, 使用特征签名代替描述符，是为了引入泛型语法后能描述泛型参数化类型 |
| RuntimeVisibleAnnotations           | 类，方法表，字段表 | JDK1.5+, 为动态注解提供支持。该属性用于指明哪些注解是运行时(运行时反射调用) 可见的 |
| RuntimeInvisibleAnnotations         | 类，方法表，字段表 | JDK1.5+, 与上面的作用正好相反                                |
| RuntimeVisibleParamterAnnotations   | 方法表             | JDK1.5+, 作用于方法参数                                      |
| RuntimeInVisibleParamterAnnotations | 方法表             | JDK1.5+, 与上面相反                                          |
| AnnotationDefault                   | 方法表             | JDK1.5+, 记录注解类元素的默认值                              |
| BoostrapMethods                     | 类文件             | JDK1.7+, 保存 invokedynamic 指令引用的引导方法限定符         |
|                                     |                    |                                                              |
|                                     |                    |                                                              |
|                                     |                    |                                                              |
|                                     |                    |                                                              |

- 对于每个属性，它的名称需要从常量池中引用一个 CONSTANT_Utf8_info 类型的常量来表示，而属性值的结构是完全自定义的，只需要通过一个 u4 的长度属性去说明属性值所占用的位数即可

| 类型 | 名称                 | 数量             |
| ---- | -------------------- | ---------------- |
| u2   | attribute_name_index | 1                |
| u4   | attribute_length     | 1                |
| u1   | info                 | attribute_length |

#### Code 属性

- 方法体中代码最终会变为字节码指令存储在 Code 属性内
- Code 属性出现在方法表的属性集合中
- 接口或抽象类中的方法不存在 Code 属性，因为没有方法体
- 结构

| 类型           | 名称                   | 数量                   |
| -------------- | ---------------------- | ---------------------- |
| u2             | attribute_name_index   | 1                      |
| u4             | attribute_length       | 1                      |
| u2             | max_stack              | 1                      |
| u2             | max_locals             | 1                      |
| u4             | code_length            | 1                      |
| u1             | code                   | code_length            |
| u2             | exception_table_length | 1                      |
| exception_info | exception_table        | exception_table_length |
| u2             | attributes_count       | 1                      |
| attribute_info | attributes             | attributes_count       |
|                |                        |                        |
|                |                        |                        |

 - attribute_name_index 是指向 CONSTANT_Utf8_info 型常量的索引，固定为 "Code",代表了属性名称
 - attribute_length指向了长度，由于 名称 和长度 一共为6字节，所以属性值的固定长度位整个属性表的长度减去 6 个字节
 - max_stack 代表了操作数栈 (Operand Stacks) 深度的最大值。虚拟机会根据这个值来分配栈帧(Stack Frame) 中的操作栈深度
 - max_locals 代表了局部变量表所需的存储空间。
    - 单位是 Slot。
    - 对于 byte,char,float,int,short,boolean 和 returnAddress 等长度不超过32位的数据类型，每个局部变量占用一个 Slot
    - 而对于 double 和 long 两种 64 位的数据类型则需要两个 Slot 存放
    - 方法参数（包括隐含的this）,显式异常处理器的参数，方法体中定义的局部变量都需要使用局部变量表来存放
    - 局部变量表中的 Slot 是可以重用的，因此总大小不是所有局部变量之和
- code_length 和 code 是迎来存储字节码指令的， 一个 u1 的数据类型的取值范围是 0x00 ~ 0xFF, 对应十进制的 0 ~255，所以一共可以表达 255 条指令，目前已经定义了 200 多条了
- 异常表并不是必须的，格式如下

| 类型 | 名称                                                   | 数量 |
| ---- | ------------------------------------------------------ | ---- |
| u2   | start_pc                                               | 1    |
| u2   | end_pc                                                 | 1    |
| u2   | handler_pc                                             | 1    |
| u2   | catch_type (指向一个 CONSTANT_Class_info 型常量的索引) | 1    |

 - 假如 当字节码在 第 start_pc 到 end_pc 行(指的是字节码相对于方法体开始的偏移量而不是源码行号) 出现了 子类型为 catch_type 或者其子类的异常, 则转到 handler_pc 行继续处理
 - catch_type 为 0时，代表任意异常情况都需要转向到 handler_pc 处进行处理

#### Exceptions 属性

- 列举出方法中可能抛出的受检异常,也就是 throws 关键字后面列举的异常
- 结构

| 类型 | 名称                  | 数量                |
| ---- | --------------------- | ------------------- |
| u2   | attibute_name_index   | 1                   |
| u4   | attribute_length      | 1                   |
| u2   | number_of_exception   | 1                   |
| u2   | exception_index_table | number_of_exception |

- number_of_exception 表示可能抛出这么多种异常
- 每一种 受检异常用一个 exception_index_table 表示，exception_index_table 是一个指向常量池中 CONSTANT_Class_info 型常量的索引

#### LineNumberTable 属性

- 描述 Java 源码行号与字节码行号(字节码的偏移量)之间的关系，并非是必需的
- 假如不生成的话，抛出异常时不会生成行号，调试时也无法打断点
- 结构

| 类型             | 名称                     | 数量                     |
| ---------------- | ------------------------ | ------------------------ |
| u2               | attribute_name_index     | 1                        |
| u4               | attribute_length         | 1                        |
| u2               | line_number_table_length | 1                        |
| line_number_info | line_number_table        | line_number_table_length |

- line_number_table 是一个数量为 line_number_table_length ，类型为 line_number_info 的集合
- line_number_info 表包括了 start_pc 和 line_number 两个 u2 类型的数据，前者是字节码行号，后者是java源码行号



#### LocalVariableTable 属性

- 用于描述 栈帧中局部变量表中的变量与Java 源码中定义的变量之间的关系
- 不是运行时必需的信息，如果不生成，那么方法被引用时，参数名称将丢失
- 结构

| 类型                | 名称                        | 数量                        |
| ------------------- | --------------------------- | --------------------------- |
| u2                  | attribute_name_index        | 1                           |
| u4                  | attribute_length            | 1                           |
| u2                  | local_variable_table_length | 1                           |
| local_variable_info | local_variable_table        | local_variable_table_length |

- local_variable_info 代表了一个栈帧与源码中的局部变量的关联，结构如下

| 类型 | 名称             | 数量 |
| ---- | ---------------- | ---- |
| u2   | start_pc         | 1    |
| u2   | length           | 1    |
| u2   | name_index       | 1    |
| u2   | descriptor_index | 1    |
| u2   | index            | 1    |

- start_pc 表示局部变量的生命周期开始的字节码偏移量
- length 表示作用范围的长度,与上面的那个结合起来表示局部变量在字节码之中的作用域范围
- name_index 和 descriptor_index 指向常量池中 CONSTANT_Utf8_info 型常量的索引，分别代表了这个局部变量的名称和这个局部变量的描述符
- index 是该局部变量在栈帧局部变量表中 Slot 的位置。假如是 64 位数据类型，则占用两个

#### SourceFile 属性

- 用于记录生成这个 Class 文件的源码名称, 也是可选的
- 假如没有，抛出异常时，堆栈就不会显示出错代码所属的文件名。
- 属性是定长的属性。结构

| 类型 | 名称                 | 数量 |
| ---- | -------------------- | ---- |
| u2   | attribute_name_index | 1    |
| u4   | attribute_length     | 1    |
| u2   | sourcefile_index     | 1    |

- sourcefile_index 指向常量池 CONSTANT_Utf8_info 型常量的索引，常量值是源码文件的文件名



#### ConstantValue 属性

- 该属性的作用是通知虚拟机自动为静态变量赋值
- 只有被 static 关键字修饰的变量 才可以使用该属性
- 对于类变量，可以选择在类构造器 <clinit> 方法中或者使用 ConstantValue 属性来赋值
- 其值是一个 常量池中一个字面量常量的引用



#### InnerClasses 属性

- 用于记录内部类和宿主类之间的关联。
- 如果一个类中定义了内部类，那编译器将会为它以及所包含的内部类生成 InnerClass 属性。结构

| 类型             | 名称                 | 数量              |
| ---------------- | -------------------- | ----------------- |
| u2               | attribute_name_index | 1                 |
| u4               | attribute_length     | 1                 |
| u2               | number_of_classes    | 1                 |
| inner_class_info | inner_calss          | number_of_classes |

- 每个内部类的信息都由一个 inner_class_info 表来进行描述。结构

| 类型 | 名称                    | 数量 |
| ---- | ----------------------- | ---- |
| u2   | inner_class_info_index  | 1    |
| u2   | outer_class_info_index  | 1    |
| u2   | inner_name_index        | 1    |
| u2   | inner_class_access_flag | 1    |

- inner_class_info_index 和 outer_class_info_index 指向常量池，表示 内部类和 宿主类的符号引用
- inner_name_index 指向常量池中 utf8 的索引，代表内部类的名称，假如是匿名内部类，那么值为 0
- inner_class_access_flags 是内部类的访问标志。类似于类的 access_flags， 可以参考类的



#### Deprecated 和 Synthetic 属性

- 都是标志类型的布尔属性，只有存在和不存在的区别
- 所有非用户代码的类，方法及字段都应当至少设置 Synthetic 属性和 ACC_SYNTHETIC 标志中的一项。除非是实例构造器 <init> 和 类构造器 <clinit> 方法



#### StackMapTable 属性

- 该属性用于在虚拟机类加载的字节码验证阶段被新类型检查验证器使用(Type Checker)。目的在于代替以前比较消耗性能的基于数据流分析的推导验证器
- 工作原理很复杂，要去看虚拟机规范
- 一个 方法的 Code 属性最多有一个 StackMapTable 属性



#### Signature 属性

- 可选的定长属性，可以出现在类，字段表和方法表结构的属性表中。
- 任何类，接口或成员的泛型签名如果包含了类型变量 (Type Variables) 或参数化类型 (Parameterized Types) ，则 Signature 属性会为它记录泛型签名信息
- Java 的反射API能获取泛型类型就是因为有这个。结构

| 类型 | 名称                 | 数量 |
| ---- | -------------------- | ---- |
| u2   | attribute_name_index | 1    |
| u4   | attribute_length     | 1    |
| u2   | signature_index      | 1    |

- signature_index 是一个对常量池 utf8 的有效索引



#### BoostrapMethods 属性

- 用于保存 invokedynamic 指令引用的引导方法符
- 待后续详细介绍



## 字节码指令简介

- 指令是由一个字节长度，代表着某种特定操作长度含义的数字(操作码, Opcode)
- 跟随其后的零至多个代表此操作所需参数(操作数, Operands) 而构成
- 由于Java 虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数指令都只有一个操作码

### 字节码与数据类型

- java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型
- 大部分与数据类型有关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务
  - i :int
  - l: long
  - s : short
  - b : byte
  - c : char
  - f : float
  - d: double
  - a: reference

### 加载和存储指令

- 用于将数据再栈帧中的局部变量表和操作数栈之间来回传输

#### 将一个局部变量加载到操作栈

?load, ?load_<n> ...

#### 将一个数值从操作数栈存储到局部变量表

?store, ?istore_<n>

#### 将一个常量加载到操作数栈

bipush, sipush, ldc, ldc_w, ldc2_w, aconst_null, iconst_ml, iconst_<i> ...

### 运算指令

- 用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。
- 大体上分为 对 整型数据进行运算和浮点型数据进行运算两类
- byte, short, char, boolean 的计算会用 int 进行
- 整数和浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现
  - 加法指令:  iadd, ladd, fadd, dadd
  - 减法指令: isub ....
  - 乘法指令: imul ....
  - 除法指令: idiv ...
  - 求余指令: irem ...
  - 取反指令: ineg ...
  - 位移指令: ishl, ishr, iushr, lshl, lshr, lushr
  - 按位 或 指令: ior, lor
  - 按位 与 指令: iand, land
  - 按位 异或 指令: ixor, lxor
  - 局部变量自增指令: iinc
  - 比较指令: dcmpg, dcmpl, fcmpg, fcmpl, lcmp
- 运算规则比较复杂，总之是遵守了 IMME 754 的规范



### 类型转换指令

- 可以将两种不同的数值类型进行相互转换
- 虚拟机直接支持以下数值类型的宽化类型转换(Widening Numeric Conversions, 即小范围类型向大范围类型的安全转换)
  - int => long, float, double
  - long => float, double
  - float => double
- 处理窄化类型转换 (Narrowing Numeric Conversions) 时，必须显式地使用转换指令来完成, 比如 : i2b, i2c, i2s ......
  - 窄化类型转换可能会导致转换结果产生不同的正负号，不同数量级的情况
  - 虽然可能会有各种情况，但绝不会抛出运行时异常



### 对象创建与访问指令

- 类实例和对象实例都是对象，但是创建和操作均使用了不同的字节码指令
- 对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或数组元素
  - 创建类实例的指令: new
  - 创建数组的指令: newarray, anewarray, multianewarray
  - 访问类字段  和实例字段 的指令: getfield, putfield, getstatic, putstatic
  - 把一个数组元素加载到操作数栈的指令: baload ......
  - 将一个操作数栈的值存储到数组元素中的指令: bastore, castore .....
  - 取数组长度的指令: arraylength
  - 检查类实例类型的指令: instanceof, checkcast



### 操作数栈管理指令

- 虚拟机提供了许多直接操作操作数栈的指令
  - 将操作数栈顶一个或两个元素出栈: pop, pop2
  - 复制栈顶一个 或 两个 数值并将复制值或双份的复制值重新压入栈顶: dup, dup2, dup_x1, dup2_x1, dup_x2, dup2_x2
  - 将栈最顶端的两个数值互换: swap



### 控制转移指令

- 可以让 虚拟机有条件或无条件的从指定的位置指令而不是控制转移指令的下一条指令继续执行程序
- 即使在有条件或无条件地修改 PC 寄存器的值
  - 条件分支: ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, if_icmpeq, if_icmpne, if_icmplt, if_icmpgt, if_icmple, if_icmpge, if_acmpeq, if_qcmpne
  - 复合条件分支: tableswitch, lookupswitch
  - 无条件分支: goto goto_w, jsr, jsr_w, ret
- 有专门的指令集用来处理 int 和 reference 类型的条件分支比较操作，也有专门的指令用来检测 null



### 方法调用和返回指令

- invokevirtual : 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），也是最常见的
- invokeinterface: 用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用
- invokespecial: 指令用于调用一些需要特殊处理的实例方法，包括实例初始化犯法，私有方法和父类方法
- invokestatic: 指令用于调用类方法(static 方法)
- invokedynamic 指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法
  - 前面的指令的分派逻辑都固化在 虚拟机内部，但是 invokedynamic 指令的分派逻辑是由用户设所设定的引导方法决定的
- 方法返回指令是根据返回值区分的
  - ireturn
  - lreturn
  - freturen
  - dreturn
  - areturn
  - return (void 时使用)



### 异常处理指令

- java 程序中显式抛出异常的操作 (throw 语句) 都由 athrow 指令来实现
- 处理异常采用异常表而不是指令来实现



### 同步指令

- Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管理(Monitor) 来支持的
- 方法级的同步时隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中
  - 虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法
  - 方法被调用时假如被判断是持有的，那么执行线程就要求先成功持有管程，然后才能执行方法。
  - 最后无论是正常还是正常，方法完成时释放管程
  - 方法执行期间，其它线程无法获取同一个管程
  - 假如方法内部抛出异常又没处理，随着异常的抛出 管程也被释放
- 虚拟机指令集中有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义
  - monitorenter : 将栈顶元素作为 锁，开始同步
  - monitorexit: 退出同步
  - 每条调用过的 monitorenter 都必须有其对应的 monitorexit 指令
  - 为了保证 方法异常完成时对应的 monitorenter 有 moniterexit 能被执行，编译器会自动产生一个异常处理器



# 虚拟机类加载机制

## 概述

- Java 里，类型的记载，连接和初始化过程都是在程序运行期间完成的

## 类加载的时机

- 整个生命周期包括
  - 加载 (Loading)
  - 验证 (Verification)
  - 准备(Preparation)
  - 解析 (Resolution)
  - 初始化 (Initialization)
  - 使用 (Using)
  - 卸载 (Unloading)
- 验证，准备，解析 三个部分统称为 连接 (Linking)

- 加载，验证，准备，初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。
- 解析阶段则不一定，在某些情况下可以在初始化阶段之后再开始
  - 这是为了支持 Java 的运行时绑定（也称为动态绑定）
- 虚拟机并没有规定何时需要开始 类的第一个阶段， 加载
- 对于初始化阶段，则严格规定了有且仅当以下5 种情况时必须立即对类进行 "初始化",(加载验证自然要在这之前进行)
  - 遇到 new , getstatic, putstatic, invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则会触发初始化
  - 使用 反射 包下的 方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化
  - 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
  - 当虚拟机启动时，用户需要指定一个要执行的主类, 虚拟机会先初始化那个类
  - 当使用 JDK1.7 的动态语言支持时，如果一个 java.lamg.invoke.MethodHandle 实例最后的解析结果 是REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄。并且该方法句柄所对应的类没有进行过初始化，则需要先触发其初始化
  - 以上5中情况称为对类的主动引用
  - 接口的初始化，除去 第三条以外都一样

## 类加载的过程

### 加载

- 需要完成以下三件事情

  - 通过一个类的全限定名来获取定义此类的二进制字节流
    - 这个来源非常灵活，从 zip 包中读取就比如 jar war 等
    - 运行时计算生成，比如类似于动态代理
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成一个代表这个类的 java.lang.Class 对象,作为方法区这个类的各种数据的访问入口

- 一个非数组类的加载阶段是开发人员可控性最强的

  - 可以使用系统提供的引导类加载器来完成
  - 可以由用户自定义的类加载器去完成
  - 开发人员可以通过定义字节的类加载器去控制字节流的获取方式(重写类加载器的 loadClass 方法)

- 对于数组而言，数组类本身不通过类加载器创建，是由虚拟机直接创建的

  - 但是数组类的元素类型 (数组去掉所有维度的类型) 最终是要靠类加载器去创建

    

- 数组类的加载过程 （简称为C）创建过程遵循以下原则
  - 如果数组的组件类型 （去掉一个维度的类型）是引用类型，那就递归 加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（一个类必须与类加载器一起确定唯一性）
  - 如果数组的组件类型不是引用类型，虚拟机将会把 数组 C 标记为与引导类加载器关联
  - 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public

- 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中 (具体格式未做强制要求)
- 加载阶段与连接阶段的部分内容是交叉进行的。



### 验证

- 这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

#### 文件格式验证

- 验证 字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理,比如以下几项
  - 是否以魔数 CAFFBABE 开头
  - 主，次版本号是否在当前虚拟机版处理范围内
  - 常量池中常量是否有不被支持的常量类型
  - ......
- 通过了该阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的验证阶段全部是基于方法区的存储结构进行的，不再直接操作字节流

#### 原数据验证

- 对字节码描述的信息进行语义分析，保证其描述的信息符合 Java 语言规范的要求
  - 是否有父类
  - 是否继承了不允许被继承的类 (final)
  - 类中的字段，方法是否和父类产生矛盾
  - .....

#### 字节码验证

- 最复杂的一个阶段，主要是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的
  - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
  - 保证跳转指令不会跳转到方法体以上的字节码指令上
  - ......
- 在 JDK1.6 之后的 Javac 编译器和 Java 虚拟机中有一项优化，给方法体的 Code 属性增加了一项名为 StackMapTable 的属性
  - 该属性描述了方法体中所有的基本块(Basic Block, 按照控制流拆分的代码块) 开始时本地变量表和操作栈应有的状态
  - 在字节码验证期间，只用检查该属性中的记录是否合法而不用根据程序推导这些状态的合法性了，可以节省一些时间
  - 该优化可以通过参数来关闭

#### 符号引用验证

- 该校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化发生在 连接的第三阶段 - 解析中发生
- 符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验
  - 符号引用中通过字符串描述的全限定名能找到对应的类
  - 在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段



### 准备

- 一般来说，是正式为 类变量 （不包括实例变量）分配内存并设置类变量 初始值 (该数据类型的 零值) 的阶段，这些变量所使用的内存都将在方法区中进行分配。
- 假如 类字段的字段属性表存在 ConstantValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指的的值



### 解析

- 是虚拟机将常量池内的 符号引用 替换为 直接引用的过程

#### 符号引用 (Symbolic References)

- 以一组符号来描述所引用的目标
- 可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可
- 符号引用与虚拟机实现的内存布局无关，引用的目标不一定要加载到内存中

#### 直接引用(Direct References)

- 直接引用是可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄
- 直接引用和虚拟机实现的内存布局相关的
- 同一个符号引用再不同虚拟机实例上翻译出来的直接引用一般不会相同
- 如果有了直接引用，那引用的目标必定已经在内存中存在



- 虚拟机规范并未规定解析阶段具体发生的时间
- 对同一个符号引用进行多次解析请求是很常见的事情
- 除了 invokedynamic 指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行
- invokedynamic 指令是用于动态语言支持的(Java 代码不会生成这个)，它所对应的引用称为 动态调用点限定符 (Dynamic Call Site Specifier) ，此处动态的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行
- 解析动作主要针对类， 接口，类方法，接口方法，方法类型，方法句柄和调用点限定符 7 类符号引用进行

#### 类或接口的解析

- 假设当前代码所处的类为 D, 如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的引用，那么步骤如下
  - 如果 C 不是一个数组类型，那么虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。在加载过程中，由于 验证 的存在，可能会触发别的类的加载动作。一旦加载过程出现了任何异常，解析过程就宣告失败
  - 如果 C 是一个数组类型，并且数组的元素类型为对象，那么会按照上一条的规则加载 元素类型，接着由虚拟机生成一个代表此数组维度和元素的数组对象
  - 如果上面的步骤没有出现任何异常，那么 C 在虚拟机中实际已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，验证不通过就抛出 IllegalAccessError 异常

#### 字段解析

- 要解析一个未被解析过的字段符号引用，首先将会对字段表内 class_index 项中索引的 CONSTANT_Class_info 符号引用进行解析，也就是字段所属的类或接口的符号引用
- 如果解析完成，那么将这个字段所属的类或接口用 C 表示, 剩下的步骤如下
  - 如果 C 本身就包含了 简单民粹和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
  - 否则，如果 C 中实现了接口，就会按照继承关系从上往下递归搜索各个接口和它的付接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
  - 否则，按上一条的规则去搜索父类的
  - 都找不到，抛出 NoSuchFieldError 异常
- 查找过程中成功返回了引用，就会对字段进行权限校验，校验失败时会抛出 illegalAccessError
- 实际应用中，虚拟机的编译实现可能会更严格

#### 类方法解析

- 第一个步骤与字段一样，也是先解析所在类
- 接下来的步骤
  - 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现 class_index 中索引的 C 是一个接口，那就直接抛出 IncompatibleClassChangeError 异常
  - 如果通过了，在 C 中查找 简单名称和描述符都一致的方法
  - 否则，在父类中找
  - 否则，在 C 实现的接口列表和父接口类别中递归查找，如果有，说明是抽象方法，抛出 AbstractMethodError 异常
  - 否则，抛出 NoSuchMethodError
- 找到直接引用后，会进行权限校验

#### 接口方法解析

- 也需要先解析出所在类
- 与类方法解析不同，假如在接口方法表中发现 class_index 中的索引 C 是个类而不是接口，就抛出 IncompatibleClassChangeError 异常
- 否则，在接口C中查找
- 否则，在其父接口中查找，直到 Object 为止
- 否则，抛出 NoSuchMethodError 异常
- 因接口方法 public 的，所以进行权限校验



### 初始化

- 类加载的最后一步，在这一步才真正开始执行类中定义的 Java 程序代码
- 初始化阶段是执行类构造器 <clinit>() 方法的过程

#### clinit 方法的一些细节

- clinit 方法时由编译器自动收集类中的所有类变量的赋值动作和静态语句块中语句合并产生的
- 编译器收集的顺序是由语句在源文件中出现的顺序决定的
- 静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问
- clinit 不需要显式调用 父类的 clinit 方法，虚拟机会保证父类的该方法已经执行完
- 假如一个类没有静态语句块也没有对变量的赋值操作，则编译器不会生成 clinit 方法
- 接口的 clinit 方法不需要先执行父类的 clinit 方法，除非父接口中定义的变量需要使用
- 接口的实现类在初始化时不会执行接口的 clinit 方法
- 虚拟机会保证 clinit 方法在多线程环境中被正确的加锁，同步
- 如果多个线程同时去初始化一个类，那么只有一个线程会去执行 clinit 方法，其它线程会阻塞，所以要避免在 clinit 方法中执行费时操作



## 类加载器

### 类与类加载器

- 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java 虚拟机中的唯一性
- 每一个类加载器，都拥有一个独立的类名称空间

### 双亲委派模型

从开发人员角度来看，分为以下三种类加载器

- 启动类加载器 (Bootstrap ClassLoader)

  - 负责将存放在 JAVA_HOME\lib 目录中的，或者被 -Xbootclasspath 参数所指的的路径中的，并且虚拟机识别的(比如 rt.jar)类库加载到虚拟机内存中

  - 启动类加载器无法被 Java 程序直接引用

  - 在自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可

    

-  拓展类加载器 (Extension ClassLoader): 
  - 这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，负责加载 JAVA_HOME\lib\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库
  - 开发者 可以直接使用
- 应用程序类加载器(Application ClassLoader)
  - 由 sun.misc.Launcher$AppClassLoader 实现。
  - 该类加载器是 ClassLoader 中额 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器
  - 负责加载用户类路径 (classpath) 上所指定的类库
  - 开发者 可以直接使用
- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器
  - 一般不会用继承，而是用组合来实现
  - 不是强制性的约束
  - 首选要求父加载器加载，父加载器反馈找不到时，才自己去加载



### 破坏双亲委派模型

- 第一次破坏是为了兼容 1.2 之前的代码
- 第二次破坏是为了 SPI 的实现
- 第三次破坏是为了追求动态性，比如OSGI



# 虚拟字节码执行引擎

## 运行时栈帧结构

- 栈帧 (Stack Frame) 是用于支持虚拟机进行方法调用和方法执行的数据结构。
- 它是虚拟机运行时数据区中的虚拟机栈 （Virtural Machine Stack）的栈元素。
- 栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息
- 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程
- 栈帧中需要多大的局部变量表，多深的操作数栈在编译时已经确定了，并且写到了方法表的 Code 属性之中
- 一个线程的方法调用链可能会很长，很多方法都同时处于执行状态。
- 对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧 (Current Stack Frame)，与整个栈帧相关联的方法称为当前方法 (Current Method)
- 执行引擎运行的所有字节码指令都只针对当前栈帧进行操作



### 局部变量表 (Local Variable Table)

- 是一组变量存储空间，用于存放方法参数和方法内部定义的局部变量
- 在 Java 程序编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量
- 局部变量表的容量以变量槽(Variable Slot) 为最小单位，一个 Slot 可以存放一个 32 位以内的数据类型
  - boolean ,byte,char,short,int,float,reference,returnAddress 8 中类型都是32位以内的
  - reference 的结构没有规定，但一般来说要实现两点
    - 从此引用中直接或间接地查找到对象在 Java 堆中的数据存放的起始地址索引
    - 此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息
  - returnAddress 很古老，已经不使用了
- 64 位的就是 long 和 double 了，因为局部变量表是在 线程的堆栈上，属于线程私有的，所以读写不会有线程安全问题
- 虚拟机通过索引定位的方式使用局部变量表
- 索引值的范围是从 0 开始至局部变量表最大的 Slot 数量
  - 访问 32 位的数据类型，就是 n 个 Slot
  - 访问 64 位数据类型的变量，就是同时使用 n 和 n+1,假如单独访问会抛出异常
- 方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的
  - 如果执行的是实例方法，那局部变量表中第 0 位索引的 slot 默认是用于传递方法所属对象实例的引用,即 this
  - 其余参数则按照参数表顺序排列
- 为了尽可能节省栈帧空间，局部变量表中的Slot是可以复用的
- 方法体中定义的变量，其作用域不一定会覆盖整个方法体，如果当前字节码 PC 计数器的值已经超出了某个变量的作用域，那这个变量对应的 Slot 就可以交给其它变量使用。



### 操作数栈 (Operand Stack)

- 一个 LIFO 栈，其最大深度也是在编译期确定的，写入 Code 属性的 max_stacks 数据项中
- 操作数栈的最的每一个元素可以是任意的 Java 数据类型，包括 long 和 double,64位的占两个容量
- 当一个方法开始执行时，操作数栈是空的。执行时，会有各种字节码指令往里面存放和提取内容
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，编译和类校验阶段都会验证
- 虚拟机在实现时，会让两个栈帧重叠一部分，做共用一部分数据的优化



### 动态连接

- 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。
- 持有这个引用是为了支持方法调用过程中的动态链接 （Dynamic Linking）
- Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数
- 这些符号引用一部分在类加载阶段或者第一次使用时转化为直接引用，这称为静态解析
- 而在运行期间转化为直接引用的部分称为动态连接



### 方法返回地址

- 一个方法开始执行后，只有两种方式可以退出这个方法
  - 执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者, 这是正常完成出口
  - 在执行时遇到了异常，并且这个异常没有在方法体内得到处理，这种退出为异常完成出口，此时不会有任何返回值
- 无论是哪种退出方式，都需要返回到方法被调用的位置，程序才能继续执行
  - 方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值
  - 方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧一般不会保存
- 方法退出的过程实际上就等同于把当前栈帧出栈



### 附加信息

- 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，比如调试相关的
- 一般把动态连接， 方法返回地址与其它附加信息全部归为一类



## 方法调用

- 方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法）
- Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是实际的内存布局中的入口地址

### 解析

- 类加载的解析阶段，会把一部分的方法的符号引用转化为直接引用，这个动作能进行的前提是
  - 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的
  - 也就是，调用模板在程序代码写好，编译器进行编译时就必须确定下来，这类方法调用称为解析 (Resolution)
- 符合这个条件的方法，主要包括 静态方法和私有方法两类
  - 静态方法与类型直接关联
  - 私有方法在外部不可访问
- Java 虚拟机提供了 5 条方法调用字节码指令
  - invokestatic; 调用静态方法
  - invokespecial: 调用实例构造器 <init> 方法，私有方法和父类方法
  - invokevirtual: 调用所有的虚方法
  - invokeinterface: 调用接口方法，会在运行时再确定一个实现此接口的对象
  - invokedynamic: 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。该指令的分派逻辑是由用户所设定的引导方法决定的
- 只要是被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段确定唯一的调用版本
  - 这些方法在类加载时就会把符号引用解析为直接引用，称为 非虚方法
  - final 方法和上述之外的称为 虚方法

### 分派

#### 静态分派

```java
Human man = new Man()
```

- Human 为变量的静态类型， Man 是变量的实际类型
- 静态类型的变化仅仅在使用时发生，变量本身的静态类型是不会改变的
- 静态类型是在编译期可知的
- 实际类型的变化结果在运行时才能知道，编译器在编译程序的时候并不知道一个对象的实际类型是什么
- 虚拟机在重载的时候是通过参数的静态类型而不是实际类型作为依据的，因此，在编译阶段，虚拟机会根据参数的静态类型决定使用哪个重载版本
- 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。典型就是重载
- 很多时候重载的这个版本并不是唯一的，而是一个比较合适的版本



#### 动态分派

- 动态分派跟重写有很大的关系
- 虚拟机会根据实际类型来分派 方法执行版本
  - 虚拟机 会 执行 invokevirtual 指令来执行 实例方法， invokevirtual 的执行过程如下:
  - 找到操作数栈的第一个元素所指向的对象的实际类型 (在之前的步骤中已经将 接收者 压到栈顶了， 根据实际类型就是出于这一步)
  - 如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，不通过就报 IllegalAccessError 异常
  - 否则，按照继承关系从下往上依次对 C 的各个父类进行查找
  - 始终没有的话就抛出 AbstractMethodError 异常

#### 单分派和多分派

- 方法的接收者和方法的参数称为方法的宗量
- 根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种
- Java 静态分派的时候，选择目标方法的依据有两点，因此是多分派
  - 静态类型是哪个类型
  - 方法参数是哪个类型
- Java 动态分派 的时候，只关心 方法的接收者的实际类型是什么，因此是单分派



#### 虚拟机动态分派的实现

是一些复杂的优化算法，略过



### 动态类型语言支持

Java 通过 java.lang.invoke 包 和 invokedynamic 指令 实现了动态类型



#### java.lang.invoke 包

```java
public class MethodHandleTest {
  static class ClassA {
    public void println(String s) {
      System.out.println(s);
    }
  }

  public static void main(String[] args) throws Throwable{
    Object kk = new ClassA();

    Object obj = System.currentTimeMillis() % 2 == 0 ? System.out : new ClassA();
    // 下面的代码会正确的执行
    getPrintlnMH(obj).invokeExact("hello world");
  }

  private static MethodHandle getPrintlnMH(Object receiver) throws Throwable{
    /*
    * 方法签名，第一个参数是返回值
    * */
    MethodType mt = MethodType.methodType(void.class, String.class);
    // lookup 是在指定类中查找符合给定的方法名称，方法类型，并且符合调用权限的方法句柄
    return MethodHandles
      // 构建一个 lookup 类来查找
      .lookup()
      // 开始查找符合描述的方法 类 方法名称 方法签名
      .findVirtual(receiver.getClass(), "println", mt)
      /*
       * 调用的是一个虚方法，方法的第一个参数是 this, 这里不通过参数列表而是调用 bindTo 来完成
       * */
      .bindTo(receiver);
  }
}
```

#### invokedynamic 指令

- 跟 上文的 MethodHandle 的作用机制类似
- 每一处 invokedynamic 指令的位置都称作 " 动态调用点" (Dynamic Call Site)
- 该指令的第一个参数不再是代表方法符号引用的 CONSTANT_Methodref_info 常量，而是变为 CONSTANT_InvokeDynamic_info 常量，该常量中有三个信息
  - 引导方法 (Bootstrap Method), 存放在新增的 BootstrapMethods 属性中
  - 方法类型 (MethodType)
  - 名称
- 引导方法时固定的参数，并且返回值是 java.lang.invoke.CallSite 对象。该对象是真正要执行的目标方法调用
- 根据 CONSTANT_InvokeDynamic_info 中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个 CallSite 对象，最终调用要执行的目标方法



## 基于栈的字节码解释引擎

涉及到编译原理的部分，TODO ,待补完



# 类加载与以及执行子系统的案例分析

TODO 待补完



# 字节码

## 基本概念

### 魔数 0xCAFEBABE

- class 文件的头四个字节称为魔数，而class的魔数为 0xCAFEBASE。
- 很多文件都以魔数来进行文件类型的区分
- 文件格式的制定者可以自由的选择魔数值，只要魔数值还没有被广泛的采用过且不会引起混淆即可
- 虚拟机在加载类文件之前会先检查这四个字节，如果不是 0xCAFEBASE 则会拒绝加载该文件

### javap

- 专门用来分析类文件的工具

- -c 选项

  - 可以对类进行反编译

  ```shell
  // 代码前的数字代表从方法开始算起的字节码偏移量
  Compiled from "Main.java"
  public class Main {
   // 会默认加上的构造器函数
    public Main();
      Code:
      	/*
      		aload_x 格式操作码中的一个，x 表示正在被访问的局部变量数组的位置
      		0 的话表示第一个，是用来把对象引用加载到操作数栈
      		因为非静态的函数都有第一个默认参数，那就是this，所以 aload_0 就是把 this 入栈
      	*/ 
         0: aload_0
         /*
         	invokespecial 指令调用实例初始化方法,私有方法，父类方法
         	#1 指的是产量池中的第一个
         	这里是方法引用 java/lang/Object."<init>":()V，即构造器函数
         */
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         /*
         	属于 ireturn, lreturn, dreturn, areturn 和 return 操作组中的一员
         	i 表示 int 整数，同类的还有 l 表示 long, f 表示 float, d 表示 double, a表示对象引用
         	没有前缀的表示返回 void
         */
         4: return
  
    public static void main(java.lang.String[]);
      Code:
      	/*
      		getstatic 获取指定类的静态域，并将其值压入栈顶
      		#2 表示常量池中的第二个, 这里就是 java/lang/System.out:Ljava/io/PrintStream
      		也就是 System.out 的 out
      	*/
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         /*
         	ldc 用来将常量从运行时常量池压栈到操作数栈
         	#3 代表常量池的第三个 也就是字符串 Hello World!
         */
         3: ldc           #3                  // String Hello World!
         /*
         	invokevirtual 指令调用一个对象的实例方法，
         	#4 表示 PrintStream.println(String)函数引用，并把栈顶两个元素出栈
         	也就是上面两个操作时入栈的字符串和函数引用
         */
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
  }
  ```

  - -p 选项

    - 默认显示的方法不包括私有方法，加上后可以显示 private 方法和字段

  - -v 选项

    - 会输出更多详细的信息，比如栈大小，方法参数的个数

  - -s 选项

    - 可以输出签名的类型描述符，主要是字段描述符和方法描述符
    - 字段描述符

    | 描述符      | 类型     |
    | ----------- | -------- |
    | B           | byte     |
    | C           | char     |
    | D           | double   |
    | F           | float    |
    | I           | int      |
    | J           | long     |
    | L CLassName | 引用类型 |
    | S           | short    |
    | Z           | boolean  |
    | [           | array-of |
    |             |          |

    - 方法描述符表示一个方法所需要的参数和返回值信息，格式为 (ParameterDescriptor* ) ReturnDescriptor
      - 没有返回值用 V 表示



### 栈帧

- 栈帧随着方法调用而创建，随着方法结束而销毁，每个栈帧都有自己的局部变量表，操作数栈和指向运行时常量池的引用

#### 局部变量表

- 在编译期时就确定大小
- 虚拟机使用局部变量表来完成方法调用时的参数传递，每一个方法被调用时，它的参数就会被传递到从0开始的连续局部变量列表位置上
- 假如是实例方法被调用，那么默认 0 就是 this

### 操作数栈

- 后进先出的栈，也是编译期确定
- 虚拟机提供的一些字节码指令用来从局部变量表或者对象实例的字段中复制常量或者变量到操作数栈
- 也有一些指令用于从操作数栈取走数据，操作数据和把操作结果重新入栈
- 方法调用时，操作数栈也用来准备调用方法的参数和接收方法返回的结果

## 字节码指令

### 控制转移指令

- 根据条件进行分支跳转

### 对象初始化

- new
- dup
- invokespecial

### 









