== 概述

* 虚拟机以方法作为最基本的执行单元

* *栈帧 (Stack Frame)* 则是用于支持虚拟机进行方法调用和方法执行背后的数据结构。它也是虚拟机运行时数据区中的虚拟机栈( *Virtual Machine Stack*)的栈元素

* 每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程

* 每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息

* 栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算处理，并且写入到方法表的Code属性中。所以，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序员源码和具体的虚拟机实现的栈内存布局形式。

* 对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是运行的，只有位于栈顶的栈帧才是生效的，被称为 *当前栈帧 (Current Stack Frame)*，与这个栈帧所关联的方法被称为 *当前方 (Current Method)*

* 执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作

== 局部变量表

*Local Variables Table* 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。

在Java程序被编译为 Class 文件时，就在方法的 *Code* 属性的 *max_locals* 数据项中确定了该方法所需分配的局部变量表的最大容量

=== 变量槽

* 局部变量表的容量以 *变量槽 (Variable Slot)* 为最小单位

* 虚拟机规定每个变量槽都能存放一个 boolean, byte, char, short, int, float, reference 或 returnAddress 类型的数据, 这8种数据类型，都可以是呀32位或更小的物理内存来存储

* 变量槽的长度可能随着处理器，操作系统或虚拟机实现的不同而发生变化，保证了即使在64位虚拟机种使用了64位的物理内存空间去实现一个变量槽，虚拟机仍要使用对齐和补白的手段让变量槽在外观上看起来与32位虚拟机中的一致

==== reference 类型

表示一个对象实例的引用,虚拟机规定通过引用应该可以做到以下两件事

* 根据引用直接或间接地查找到对象在 Java 堆中地数据存放的起始地址或索引

* 根据引用直接或间接地查找到对象所属数据类型在方法区中地存储地类型信息 (可以用来实现反射)

==== returnAddress

很少见了，为字节码指令 jsr ,jsr_w 和 ret 服务的，指向了一条字节码指令的地址

=== 64位的数据类型

* 对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间

* Java中只有 long 和 double 两种64位数据类型

* 这里把 long 和 double 数据类型分割存储的做法与 "long 和 double 的非原子性协定" 中允许把一次 long 和 double 数据类型读写分割为两次 32 位读写的做法有些类似

* 变量表属于线程私有的数据，因此不会有线程安全的问题

=== 变量表的访问

* 虚拟机使用索引定位的方式使用局部变量表

* 索引值的范围是从 0 开始至局部变量表最大的变量槽数量

* 如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽

* 如果是访问的64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽

* 不允许访问单独的 64 位数据的一个变量槽，否则在类加载的校验阶段就应该抛出异常

=== 变量槽的分配

* 当一个方法被调用时，虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程, 即实参到形参的传递

* 假如是实例方法, 那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用 (也就是 "this" 能访问到的参数), 其余参数则按照参数表顺序排列，占用从1开始的局部变量槽

* 参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽

=== 变量槽的重用

为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其它变量来重用

== 操作数栈

* *OPerand Stack* 是一个 LIFO 栈

* 操作数栈的最大深度也在编译的时候被写入到 *Code* 属性的 *max_stacks* 数据项中

* 操作数栈的每一个元素丢可以是包括 long 和 double 在内的任意Java数据类型,32位的数据类型所占的栈容量为1，64位数据类型所占的栈容量为2.

* java 编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过在 *max_stacks* 数据项中设定的最大值

* 操作数栈的数据类型必须与字节码指令的序列严格匹配

* 在有的虚拟机实现中，会把不同的栈帧的操作数栈或者局部变量表重复一部分，以提升效率，节约空间

== 动态连接

* 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用, 整个引用是为了支持方法调用过程中的 *动态连接(Dynamic Linking)*

* Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数

* 符号引用的一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，称为 *静态解析*

* 符号引用的另一部分会在每一次运行期间都转化为直接引用，称为 *动态连接*

== 方法返回地址

* 方法如果正常完成退出，叫做 *正常调用完成 (Normal Method Invocation Completion)*

方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中可能会保存整个计数器值

* 假如在方法执行的过程中遇到了异常，并且异常没有在方法体内得到妥善处理，这种叫做 *异常调用完成(Abrupt Method Invocation Completion)*

这个时候，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息

== 附加信息

虚拟机规范允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，这部分完全是实现方自己决定的






