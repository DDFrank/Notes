== 类加载器

虚拟机设计团队有意把类加载阶段中的 "通过一个类的全限定名来获取描述该类的二进制字节流" 这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取需要的类。实现这个动作的代码就是 "类加载器" (CLass Loader)

类加载器在 类层次划分，OSGI，程序热部署，代码加密等领域发挥重要作用

=== 类与类加载器

* 对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。

* 每一个类加载器，都拥有一个独立的类名称空间

* 比较两个类是否相等，首要前提就是这两个类必须是同一个类加载器加载的

* 上文中的 *相等*, 也包括类的 *Class* 对象的 *equals()*, *isAssignableFrom()* , *isInstance()* 方法的返回结果

=== 三层类加载器

从虚拟机的角度来看，只有两种类加载器，一个是启动类加载器 ( *Boostrap ClassLoader* ), 是虚拟机的一部分;另外一种就是其他所有的类加载器，存在于虚拟机外部，且全部继承自抽象类 *java.lang.ClassLoader*


* 启动类加载器 (Boostrap Class Loader)

** 负责加载存放在 <JAVA_HOME>\lib目录下，或者被 -Xbootclasspath参数所指定的路径存放的，而且是虚拟机能够识别的(按照名字识别)的类库

** 无法被Java程序引用，在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那么直接使用 null 即可

* 拓展类加载器 (Extension Class Loader)

** 是在类 sun.misc。Launcher$ExtClassLoader 中以Java代码的形式实现的

** 负责加载<JAVA_HOME>\lib\ext 目录中，或者被 java.ext.dirs 系统变量所指定的路径中所有的类库

** 这是一种Java系统类库的拓展机制, 允许用户将具有通用性的类库放在ext目录里以拓展 Java SE 的功能

** Java 9 之后，这种拓展机制被模块化带来的天然的拓展能力所取代

** 可以在程序中直接使用该加载器去加载Class文件

* 应用程序类加载器 (Application Class Loader)

** 这个类加载器由 sun.misc.Launcher$AppClassLoader 来实现

** 是 ClassLoader 类中 getSystemClassLoader() 方法的返回值，所以也叫做 "系统类加载器"

** 负责加载用户类路径(ClassPath)上的所有的类库

** 可以在代码中直接使用该加载器

=== 双亲委派模型

非强制性的模型，而是Java设计者们推荐给开发者的一种最佳实践

各种类加载器的层次关系被称为类加载器的 *双亲委派模型 (Parents Delegation Model)*

双亲委派模型要求除了顶层的类加载外，其余的类加载器都应有自己的父类加载器，这种关系一般不是通过继承，而是使用 组合 来实现的

==== 工作过程

* 当某个类加载器收到了类加载的请求时，首先会把这个请求委派给父类加载器

* 所有的加载请求最终都应该传送到最顶层的启动类加载器中

* 当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载

==== 双亲委派模型的好处

* Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。

* 这种优先级的层次关系可以保证Java类型体系中最基础的行为得到保证

==== 不遵守双亲委派模型的情况

* 双亲委派模型并非一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式

