== 一个类的生命周期

分为七个阶段

* 加载 (Loading)

* 连接 (Linking)

** 验证 (Verification)

** 准备(Preparation)

** 解析 (Resolution)

* 初始化 (Initialization)

* 使用 (Using)

* 卸载 (Unloading)

其中，*加载*，*连接*, *初始化* 是类的加载过程

== 类加载的时机

.Tip: 类的加载顺序必须按照 加载，验证，准备，初始化的顺序进行, 但是解析阶段则有可能在初始化阶段开始之后再开始,这样做是为了支持Java语言的运行时绑定特性(动态绑定，晚期绑定)

虚拟机规范并没有强制约束什么时候需要开始 *加载* , 但是对于 *初始化*， 规定了6中情况( *加载*，*验证*，*准备* 自然需要在此之前开始) :

* 遇到 *new* , *getstatic*, *putstatic*, *invokestatic* 这 4 条字节码指令时，如果类没有进行过初始化，则会触发初始化,对应的Java代码场景有

** 使用 *new* 关键字实例化对象的时候

** 读取或设置一个类型的静态字段(被 *final* 修饰，已在编译期把结果放入常量池的静态字段除外)

** 调用一个类型的静态方法的时候

* 使用 *java.lang.reflect* 包下的方法对类进行反射调用时，如果类没有进行过初始化，则需要先触发其初始化

* 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化

* 当虚拟机启动时，用户需要指定一个要执行的主类(main()方法类),虚拟机会先初始化那个类

* 当使用 JDK1.7 的动态语言支持时，如果一个 *java.lamg.invoke.MethodHandle* 实例最后的解析结果是 *REF_getStatic*, *REF_putStatic*, *REF_invokeStatic* 的方法句柄。并且该方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

* 当一个接口中定义了 *default* 方法时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化

* 以上6中情况称为对类的主动引用,除此之外，所有引用类型的方式不会触发初始化，称为被动引用

.Important: 接口的加载过程在 初始化 阶段和类的加载有些不一样，一个接口在初始化时，不要求其父接口全部完成了初始化，只有在真正使用到父接口的时候(如果引用接口中定义常量)才会初始化

== 类加载的过程
这里指的是上文所说的 *Loading* 阶段

=== 虚拟机的工作

* 通过一个类的全限定名来获取定义此类的二进制字节流

** 这个来源非常灵活，从 zip 包中读取就比如 jar war 等
    
** 运行时计算生成，比如类似于动态代理

** 从加密文件中获取，这是为了保护 *Class* 文件被反编译

* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

* 在内存中生成一个代表这个类的 *java.lang.Class* 对象,作为方法区这个类的各种数据的访问入口

=== 非数组类型的加载阶段可操作性很强

* 可以使用系统提供的引导类加载器来完成

* 可以由用户自定义的类加载器去完成

* 开发人员可以通过定义字节的类加载器去控制字节流的获取方式(重写类加载器的 loadClass 方法)

=== 数组类型的加载阶段

.Tip: 对于数组而言，数组类本身不通过类加载器创建，是由虚拟机直接在内存中动态构造。但是数组类的元素类型 (ElementType 数组去掉所有维度的类型) 最终是要靠类加载器去创建

以下以C简称数组类
    
* 如果数组的 *组件类型* （ComponentType 去掉一个维度的类型, 不是前面所称的 *元素类型* ）是引用类型，那就递归加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识（一个类必须与类加载器一起确定唯一性）

* 如果数组的组件类型不是引用类型，虚拟机将会把 数组 C 标记为与引导类加载器关联

* 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为 public


加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中 (具体格式未做强制要求)
类型数据妥善安置在方法区后之后，会在Java堆内存中实例化一个`java.lang.Class`类的对象, 这个对象将作为程序访问方法区中的类型数据的外部接口
加载阶段与连接阶段的部分内容是交叉进行的。


== 验证

这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

大致会进行下面4项验证

=== 文件格式验证

字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理

* 是否以魔数0xCAFEBABE开头

* 主、次版本号是否在当前Java虚拟机接受范围之内

* 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。

* 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量

* CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据

* Class文件中各个部分及文件本身是否有被删除的或附加的其他信息

等等还有很多
只有通过了该阶段的验证，字节流才被允许进入Java虚拟机内存的方法区中进行存储
后面三个阶段的验证是基于方法区的存储结构的

=== 元数据验证阶段

第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要
求:

* 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）

* 这个类的父类是否继承了不允许被继承的类（被final修饰的类）

* 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法

* 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方
法重载，例如方法参数都一致，但返回值类型却不同等）

等等很多

第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息

=== 字节码验证

第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定
程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要
对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害
虚拟机安全的行为

* 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作
栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况

* 保证任何跳转指令都不会跳转到方法体以外的字节码指令上

* 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的


.Tip:由于数据流分析和控制流分析的高度复杂性，Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中，在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行。具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性，这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）开始时本地变量表和操作栈应有的状态，在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可。这样就将字节码验证的类型推导转变为类型检查，从而节省了大量校验时间


=== 符号引用验证
最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。

* 符号引用中通过字符串描述的全限定名是否能找到对应的类

* 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段

* 符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当
前类访问

符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机
将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如：
java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等


== 准备阶段

是正式为类中定义的变量(即静态变量)分配内存并设置类变量初始值的阶段。

要注意两点

* 这个阶段只会初始化类变量，不包括实例变量（实例变量将会在对象实例化时随着对象一起分配在Java堆中）

* 初始化变量的初始值在 *通常情况* 下时数据类型的零值

[source]
----
public static int value = 123;
----

那么 *准备* 阶段过后的初始值为0而不是123，因此此时尚未开始执行任何Java方法, 而把 *value* 赋值为 123 的 *putstatic* 指令是程序被编译后，存放于构造器<clinit>() 方法之中。这个是发生在类的初始化阶段

* 初始值也有 *特殊情况*，即 类变量被声明为 *final* 的情况, 这个时候，如果类字段的字段属性表中存在 *ConstantValue* 属性，那么在准备阶段变量值就会被初始化为 *ConstantValue* 属性值所指定的初始值

[source]
----
public static final int value = 123;
----

== 解析阶段

是将常量池内的符号引用替换为直接引用的过程

* 符号引用 (Symbolic References) : 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。

** 符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容

** 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的

* 直接引用 (Direct Refrences) : 直接引用是可以直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄

** 直接引用是和虚拟机实现的内存布局直接相关的

** 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同

** 如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在

* 对方法或字段的访问，也会在解析阶段中对其可访问性(public, protected,private,<package>)进行检查

=== 解析阶段的发生时间

* 虚拟机规范并未规定解析阶段发生的具体时间，只要求执行 *ane-warray*, *checkcast*, *getfield*, *getstatic*, *instanceof*, *invokedynamic*, *invokeinterface*, *invoke-special*, *invokestatic*, *invokevirtual*, *ldc*, *ldc_w*, *ldc2_w*, *multianewarray*, *new*, *putfield*, *putstatic* 这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析

* 虚拟机实现可以根据需要来自行判断到底是类被加载器加载时对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析

=== 对符号引用进行解析可能会缓存

* 对同一个符号引用进行多次解析请求是很常见的事情，出了 *invokedynamic* 指令以外，虚拟机实现可以对第一次解析的结果进行缓存, 比如在运行时直接引用常量池中的记录，并把常量标识为已解析状态。从而避免解析动作重复进行。

* 无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功，同样地，如果第一次解析失败了，其它指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中

* 不过对于 *invokedynamic* 指令，上面的规则就不成立了。该指令是用于动态语言支持的，*动态* 的含义是必须等到程序实际运行到这条指令时，解析动作才能进行

=== 类或接口的解析

假设当前代码所处的类为D, 如果要把一个从未解析过的符号引用 N 解析为一个类型或接口 C 的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤:

* 如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给D的类加载器去加载这个类 C。在加载过程中，由于元数据验证，字节码验证的需要，有可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程将宣告失败

* 如果 C 是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似 "[Ljava/lang/Integer]"的形式，那将会按照第一点的规则加载数组元素类型。如果 N 的描述符如前面所假设的形式，需要加载的元素类型就是 "java.lang.Integer"，接着由虚拟机生成一个代表该数组维度和元素的数组对象

* 如果上面的步骤没有出现任何异常，那么 C 在虚拟机中实际上已经称为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的权限。没有权限则会抛出 *java.lang.IllegalAccessError* 异常

* 针对访问权限验证，在JDK9引入了模块化以后，一个public类型也不再意味着程序任何位置都有它的访问权限，还必须检查模块间的访问权限

=== 字段的解析

* 要解析一个未被解析过的字段符号引用，首先将会对字段表内 *class_index* 项中索引的 *CONSTANT_Class_info* 符号引用进行解析, 也就是字段所属的类或接口的符号引用。

* 如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败

* 如果解析成功完成，那把这个字段所属的类或接口用 C 表示，那么虚拟机规范要求按照以下步骤对 C 进行后续字段的搜索

** 如果 C 本身就包含了简单名称和字段描述符都与目标相匹配的字段，要返回这个字段的直接引用，查找结束

** 否则，如果 C 中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

** 否则，如果 C 不是 *java.lang.Object* 的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束

** 否则，查找失败，抛出 *java.lang.NoSuchFieldError* 异常

** 如果查找过程成功返回了引用，将会对这个字段进行权限验证,如果发现不具备对字段的访问权限，将抛出 *java.lang.IllegalAccessError* 异常

=== 方法解析

* 与字段解析的第一步一样，也是需要先解析出方法表的 *class_index* 项中索引的方法所属的类或接口的符号引用， 如果解析成功，（接下来也用C表示），接下来虚拟机将会按照如下步骤进行后续的方法搜索:

* 由于 Class 文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现 *class_index* 中索引的C是个接口的话，那就直接抛出 java.lang.IncompatibleClassChangeError 异常

* 接着在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束

* 否则在C的父类中递归查询是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束

* 否则，在类C实现的接口列表以及它们的父接口中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明C是一个抽象类，查找结束，抛出 java.lang.AbstractMethodError 异常

* 否则，宣告方法查找失败，抛出 java.lang.NoSuchMethodError

* 最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果没有访问权限，将会抛出 java.lang.NoSuchMethodError

=== 接口方法解析

* 接口方法也是需要先解析出接口方法表的 *class_index* 项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：

* 如果在接口方法表中发现 *class_index* 中的索引C是个类而不是接口，那么就直接抛出java.lang.IncompatibleClassChangeError异常

* 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束

* 否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束

* 对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找 （各个虚拟机厂商可能会有更严格的约束）

* 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常


.Important: JDK9之前，Java接口中的所有方法都是public的，所以不存在访问权限的问题。但是 JDK9 中增加了接口的静态私有方法，也有了模块化的访问约束，所以 JDK9 起就有可能出现访问控制异常



== 初始化

* 类加载过程的最后一个步骤

* 到此阶段。Javau虚拟机才真正开始执行类中编写的Java程序代码, 将主导权移交给应用程序

* 初始化阶段就是执行类构造器 <clinit>（） 方法的过程

=== <clinit>() 方法

* 是编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的

* 编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问 (非法前向引用变量)

.Tip: java初始化过程中，假如某个类或接口的成员变量出现在静态或非静态代码块中，通过简单名称来访问且不是一个赋值不等式的左值，那么在使用前必须对该变量进行声明


* <clinit>() 方法与类的构造函数不同，不需要显式地调用父类构造器，虚拟机会保证在子类的 <clinit> 方法执行前，父类的<clinit>() 方法已经执行完毕。

.Tip: 所以 Object 肯定是虚拟机中第一个被执行 <clinit>() 方法的

* <clinit>() 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 <clinit>() 方法

* 接口中不能使用静态代码块，但是仍然由变量初始化的赋值操作，所以也会生成 <clinit>() 方法, 但是接口不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法,只有当使用到父接口中定义的变量时，父接口才会被初始化

* 虚拟机必须保证一个类的<clinit>()方法在多线程环境中被正确地加锁同步, 如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其它线程都需要阻塞等待
