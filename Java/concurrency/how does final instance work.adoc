== final 域的内存语义

对于 final 域，编译器和处理器需要遵守两种重排序规则

=== 写final域的重排序规则

* 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序

** JMM禁止编译器把final域的写重排序到构造函数之外

** 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外

** 这样可以保证在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障

=== 读final域的重排序规则

* 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序

=== 需要确保对象引用不在构造函数中逸出，才能保证final域被正确地初始化

假如 对象引用在 构造函数中逸出了，那么别的线程可能读到没有初始化过的 final 域的值

因为对 final 域的赋值可能在构造函数中被重排序掉




