== 线程的实现

* 线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开

* 各个线程既可以分享进程资源(内存地址，文件I/O等), 又可以独立调度


=== 内核线程实现 (1 : 1 实现)

==== 内核线程 (Kernel-Level Thread, KLT)

* 就是直接由操作系统内核支持的线程

* 这种线程由内核来完成线程切换,内核通过操纵调度器（Scheduler）对线程进行调度, 并负责将线程的任务映射到各个处理器上

* 每个内核线程可以视为内核的一个分身，支持多线程的内核就被称为多线程内核 (Multi-Threads Kernel)

==== 轻量级进程 (Light Weight Process, LWP)

* 一般不会直接使用内核线程，而是使用轻量级进程 (内核线程的高级接口)

* 轻量级进程就是通常意义上所讲的线程

* 每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。

这种 轻量级进程与内核线程之间 1:1 的关系称为一对一的线程模型

==== 线程模型的优缺点

* 优点

** 每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作

* 局限性

** 由于是基于内核线程实现的，所以各种线程操作，如创建，析构及同步，都需要进行系统调用，而系统调用因为要在内核态和用户态之间相互切换，是比较昂贵的

** 每个轻量级线程都需要有一个内核的支持，因此轻量级进程要消耗一定的内核资源 (如内核线程的栈空间), 因此一个系统支持轻量级进程的数量是有限的

=== 用户线程实现 (1: N 实现)

* 用户线程的建立，同步，销毁和调度完全在用户态中完成，不需要内核的帮助，因此可能是非常快速且低消耗的

* 线程完全由用户态自己控制，实现起来很困难


=== 用户线程加轻量级进程混合实现 (N : M 实现)

* 将内核线程与用户线程一起使用的实现方式，也就是 N: M 实现

* 用户线程还是完全建立在用户空间中，因此用户线程的创建，切换，析构等操作比较廉价，可以支持大规模的用户线程并发

* 操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁

* 这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程完成，降低了整个进程被完全阻塞的风险

== Java 线程的实现

不受虚拟机规范的约束，主流的都是 1:1 的

=== Java 线程的调度

==== 线程调度

* 协同式 (Cooperative Threads-Scheduling) 线程调度

线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，主动通知系统切换到另外一个线程上去

这样实现起来很简单，但是假如代码编写有问题那么可能会引起整个系统的崩溃

* 抢占式 (Preemptive Threads-Scheduling) 线程调度

** 每个系统将有系统来分配执行时间，线程的切换不由线程本身来决定。

** 此时，线程的执行时间是系统可控的

** Java使用的就是这种调度方式

== 线程的状态转换

Java语言定义了6种线程状态，在任意一个时间点种，一个线程只能有且只有其中的一种状态，并且可以互相转换

* 新建 (New) : 创建后尚未启动的线程处于这种状态

* 运行 (Runnable): 包括操作系统线程状态中的Running和Ready, 也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间

* 无限期等待 (Waiting) : 处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态:

** 没有设置 Timeout 参数的 Object::wait() 方法

** 没有设置 Timeout 参数的 Thread::join() 方法

** LockSupport::park() 方法

* 限期等待 (Time Waiting) : 处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入无限期等待状态:

** Thread::sleep() 方法

** 设置了 Timeout 参数的 Object::wait() 方法

** 设置了 Timeout 参数的 Thread::join() 方法

** LockSupport::parkNanos() 方法

** LockSupport::parkUntil() 方法

* 阻塞 (Bloked): 线程阻塞了，在程序等待进入同步区域的时候，线程将进入这种状态

** *阻塞状态* 与 *等待状态* 的区别是 *阻塞状态* 在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生

** *等待状态* 则是在等待一段时间，或者唤醒动作的发生

* 结束 (Terminated) : 已终止线程的线程状态，线程已经结束执行

