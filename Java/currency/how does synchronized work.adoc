= synchronized 是怎么工作的

JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但是两者的实现细节不同

* 代码块同步是使用 monitorenter 和 monitorexit 实现的
* 方法同步的细节并未在规范中得到说明(也可以用这两个指令来实现)

monitorenter 指令在编译后插入到同步代码块的开始位置, monitorexit 是插入到方法结束处和异常处。JVM会保证每个 monitorenter 必须有对应的 monitorexit 与之配对

任何对象都有一个 monitor 与之关联, 当且一个 monitor 被持有后，它将处于锁定状态。
线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即获取对象的锁

== synchronized 用的锁是存在对象组里的

* 对象是数组类型的时候，JVM用3个 word 存储对象头
* 非数组类型时，用 2 个 word 存储对象头
32 位虚拟机中，一个 word 等于 4 个字节

TODO
对象头的存储结构可以补完

== 锁的升级

* JavaSE 1.6 开始为了减少获得锁和释放锁带来的性能消耗，引入了 *偏向锁* 和 *轻量级锁*

* 锁的级别从高到低分别为: 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁 -> 

* 锁的状态会随着竞争情况逐渐升级，一旦升级就不能降级

=== 偏向锁

* 大多数情况下，锁不但不存在多线程的竞争，而且总是由同一个线程多次获得。

* 为了让线程获得锁的代价更低而引入了偏向锁。

* 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。

* 如果测试成功，表示线程已经获得了锁。

* 如果测试失败，则需要再测试一下MarkWord中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁(此时很有可能偏向锁已经撤销)；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。(很有可能是第一次获取锁的情况)

==== 偏向锁的撤销

* 当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁

* 偏向锁的撤销，需要等待全局安全点。
** 首先暂停持有偏向锁的线程
** 检查线程释放还在活动，还在活动的话，是的话就升级锁
** 不是的话被其它线程抢占

可以使用JVM参数关闭偏向锁 -XX:-UseBiasedLocking=false
JDK15开始会废除偏向锁

=== 轻量级锁

==== 加锁
线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中(Displaced Mark Word)。然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁

==== 解锁
轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁
