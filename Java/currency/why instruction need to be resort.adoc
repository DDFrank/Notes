== Java内存模型的基础
=== 并发模型

并发模型通常需要解决两个问题

* 线程之间如何通信
* 线程之间如何同步

而在命令式的编程模型中，线程之间的通信机制有2种

* 共享内存

** 线程之间共享的公共状态通过读写共享的内存来进行的，也就是隐式的通信

** 程序必须显式指定某段代码或者方法是同步的，也就是显式的同步


* 消息传递
 
 
** 线程之间没有公共状态, 通信是显式的

** 线程要接收消息的前提是消息要被发出来，也就是隐式的同步

Java 采用的是共享内存的并发模型

=== Java的内存模型

所有的 instance, static, 和 array 都存在堆内存中

堆内存是所有线程可以访问的，因此这个部分都是共享变量


局部变量，方法定义参数 和 异常处理器参数都属于 栈上的内容，因此不会有共享变量的问题

JMM规定了线程之间和主内存的关系

* 线程之间的共享变量存储在主内存中

* 每个线程都有一个本地内存(抽象概念，包括缓存，寄存器，写缓冲区等), 本地内存存储了线程读/写共享变量的副本

* 线程之间需要通信的话，需要在主内存区交换数据, 也就是线程之间相互通信的过程

* 这个通信的过程由JMM控制，JMM通过控制主内存与每个线程的本地内存之间的交互，来为程序提供内存可见性的保证


== 源代码到指令序列的重排序

为了提高程序执行的性能，编译器和处理器通常会对指令进行重排序

* 编译器的优化排序: 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序

* 指令级并行的重排序: 现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序

* 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行

上述这些重排序的过程可能会导致多线程的程序在运行时出现问题。

因此,对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。


对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序

==== 处理器为什么要对读/写操作进行重排序

现代的处理器使用写缓冲区临时保存向内存写入的数据。

写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。

同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。

虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。

这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致

因此，处理器会对读写操作进行重排序


=== 编译器为什么要对指令进行重排序
为了性能考虑










 
 
