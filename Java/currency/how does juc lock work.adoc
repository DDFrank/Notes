=== Lock接口的好处
Lock接口提供了 synchronized 关键字所不提供的特性

* 非阻塞的获取锁: 当前线程尝试获取锁，如果这一时刻没有别的线程获取到锁，则成功获取并持有锁

* 能被中断地获取锁: 获取到锁的线程能够响应中断。持有锁的线程被中断时，中断异常将会被抛出，同时锁会被释放

* 超时获取锁: 在指定时间内去获取锁，如果到了指定时间还没能成功获取锁，那么就返回

=== 队列同步器
队列同步器AbstractQueuedSynchronizer，是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作

同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect, int update)）来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件

一个例子
```java
public class Mutex implements Lock {
    // 推荐的方式是使用静态内部类
    private static class Sync extends AbstractQueuedSynchronizer {
        // 是否处于同步状态
        @Override
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        // 当状态为0的时候获取锁
        @Override
        protected boolean tryAcquire(int acquires) {
            // 通过 cas 设置锁状态，假如设置成功就代表获取锁成功了
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        // 释放锁，将状态设置为0
        @Override
        protected boolean tryRelease(int acquires) {
            if (getState() == 0) throw new IllegalArgumentException();
            setExclusiveOwnerThread(
                null
            );
            setState(0);
            return true;
        }

        Condition newCondition() {
            return new ConditionObject();
        }
    }

    private final Sync sync = new Sync();

    // 将锁的操作代理到内部类 Sync 即可
    public void lock() {
        sync.acquire(1);
    }

    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    }

    public void unlock() {
        sync.release(1);
    }

    public Condition newCondition() {
        return sync.newCondition();
    }

}

```


