== 单元的粒度

* 对单元的理解取决于自己，可能是一个函数，也可能是一个类

* 从冰淇淋模型到金字塔模型

== 为什么要做单元测试

* 单元测试是发现程序缺陷的第一个环节

** 错误发现的越晚，修复成本就越高

* 单元测试能发现程序的设计问题
** 80%的软件错误是设计阶段引入的，设计的越差，单元测试就越不好写

* 单元测试可以对代码进行进一步说明
** 比如依赖的服务的返回结果中，有哪些数据是真正需要用到的
** 平常看一些开源框架的代码时，如果搞不清楚一部分代码的设计意图，那么可以看单元测试

* 单元测试为代码重构提供了有力保障

== 怎么做单元测试

=== 模拟的对象的分类

* Dummy Object

传递给调用者但是通常不会使用的对象，只是为了填满参数列表

* Test Stub

提供封装好的响应，记录下调用次数

* Test Spy

将测试内部的输出返回给测试用例

* Mock Object

针对相应的参数返回对应的响应值

* Fake Object

只是为了让其它程序能正常工作,比如内存数据库

=== 什么时候适合用mock

* 对象提供非确定的结果时

比如当天的时间和或者当前的温度

* 对象的某些状态很难重现

比如调用超时，网络错误

* 方法执行太慢

需要初始化数据库等等

* mock的对象仅为测试使用

=== 怎么设计测试用例

* 基于意图去设计

考虑程序的输入输出，或者是程序引起了什么副作用

* 实际操作的时候，可以适当查看代码结构，针对每一个 if else 进行设计

* 不要测试被测试过的东西

* 不要测试外部依赖

* 通常测试底部的函数

* 测试应该以断言结尾

=== 没有时间写单元测试

* 提高单元测试的效率

** 好的代码设计

** 利用好工具和框架来提升效率

* 还是没有时间

可以裸飘，但是在发现bug或者是hotfix后，补充单元测试
