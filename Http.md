# 基础
## 结构
Http从上往下分为

- 应用层
    提供应用服务，FTP DNS啥的
- 传输层
    用于数据传输 TCP UDP
- 网络层
    处理在网络上流动的数据包
- 链路层
     处理硬件部分

每过一层封装一个首部，收到到时候层层剥开首部
## IP
    主要作用是把各种数据包传送给对方，需要知道IP地址和MAC地址（网卡
    所属的固定地址）

## TCP
    位于传输层，提供可靠的字节流服务，三次握手

## DNS服务
    位于应用层，提供域名到IP地址之间的解析服务

## URL和URI
### URI
    统一资源标识符

- Uniform
        规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别
        资源指定的访问方式
- Resource
        资源的定义是 可以标识的任何东西
- Identifier
        表示可以标识的对象

### URL
    标识资源的地点，URL是URI的子集

### URI格式

- 协议方案名: http://
- 登录信息（认证: user:pass@(可选)
- 服务器地址: www.example.jp
- 服务器端口号： :80
- 带层次的文件路径: /dir/index.html?uid=1#ch1
- 查询字符串: ?uid=1
- 片段标识符: #ch1 (通常用于标记已获取资源中的子资源)

## 请求报文
- 请求方法
- 请求URI
- 协议版本
- 可选的请求首部字段(请求头)
- 内容实体

## 响应报文
- 协议版本
- 状态码
- 用于解释状态码的原因短语
- 可选的响应首部字段
- 实体主体

## HTTP是不保存状态的协议
    HTTP协议自身不对请求和响应之间的通信状态进行保存
    有了Cookie再用HTTP协议通信，才能管理状态

#### 如果不是访问特定资源和是对服务器本身发起的请求，可以用一个*来代替URI
L: OPTIONS * HTTP/1.1

## HTTP方法
- GET
    用来请求访问已被URI识别的资源。指定的资源经服务器端解析后返回响应内容
- POST
    用来传输实体的主体
- PUT
    用来传输文件，由于不带验证机制，基本只在REST接口中出现
- HEAD
    跟GET一样，就是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间
- DELETE
    删除文件，跟PUT相反，不过也不带验证机制
- OPTIONS
    用来查询针对请求URI指定的资源支持的方法
- TRACE
    让WEB服务端将之前的请求通信返回给客户端的方法，不常用，而且容易引起XST攻击
- CONNECT
    要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL,TLS协议
    把通信内容加密后经网络隧道传输

#### 长连接和管线化 
    初始版本的HTTP协议是发送一次请求就要建立/断开一次TCP连接
    后来1.1版本默认都是长连接
    在长连接的基础上又实现了管线化技术，能够处理并发的请求

## Cookie
    通过在请求和响应报文中写入Cookie信息来控制客户端的状态
    Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。
    当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值发送出去
    服务端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息

# Http信息
## 报文的结构
- 请求行
    包含用于请求的方法，请求URI和HTTP版本
- 状态行
    包含表明响应结果的状态码，原因短语和HTTP版本
- 首部字段
    包含表示请求和响应的各种条件和属性的各类首部
    + 通用首部
    + 请求首部
    + 响应首部
    + 实体首部

## 编码提升传输效率
    传输时编码能够有效处理大量的访问请求，但是会消耗更多的CPU资源
## 报文主体和实体主体的差异
- 报文
    HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输
- 实体
    作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。

通常,报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异

## 压缩传输的内容编码
    指明应用在实体内容上的编码格式，并保持实体信息原样压缩
    内容编码后额实体由客户端接收并负责解码

## 分割发送的分块传输编码
    在传输大容量数据时，通过数据分割成多块，能够让浏览器逐步显示页面。
    这种把实体主体分块的功能称为分块传输编码
    由接收的客户端负责解码，恢复到编码前的实体主体

## 发送多种数据的多部分对象集合
    发送的一份报文主体可含有多类型实体
- multipart/form-data
    在web表单文件上传时使用
-状态码 206 响应报文包含了多个范围的内容时使用

使用 boundary 字符串来划分多部分对象集合指明的各类实体
在 boundary字符串指定的各个实体的起始行之前插入 "--"标记
而在多部分对象集合对应的字符串的最后插入"--"标记作为结束

## 获取部分内容的范围请求
    会用到首部字段 Range 来指定资源的byte范围。形式如下
        Range: bytes = 5001 -10000
        Range: bytes = 5001- (表示5001之后全部的)
        Range: bytes = -3000, 5000-7000(多重范围)

    服务器会返回状态码为206 partial Content的响应报文
    并会在首部字段 Content-Type标明 multipart/byteranges后返回响应报文

    如果服务器无法回应，则会返回200 和 完整的实体内容

## 内容协商机制
    客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。
    内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准
    某些首部字段是为基准
- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

内容协商技术主要有以下三种类型
- 服务器驱动协商
    以请求的首部字段为参考，在服务器端自动处理。
    但对用户来说，以浏览器发送的信息作为判定的依据，不一定能筛选出最优内容
- 客户端驱动协商
    用户从浏览器显示的可选项列表中手动选择，也可以利用JS
- 透明协商
    以上两种的结合

# 状态码
- 200
    请求被成功处理
- 204
    请求已经成功处理，但是返回的响应报文中不包含该实体的主体部分
    另外，也不允许返回任何实体的主体
    一般在只需要客户端往服务端发送新消息的时候使用
- 206
    范围请求，响应报文中的 Content-Range 指定范围的实体内容

- 301
    永久性重定向，该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI
    浏览器这时候可能会更新书签
- 302
    临时性重定向，该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问
- 303
    表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源
当301，302，303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送
- 304
    表示客户端发送附带条件的请求时，服务端允许请求访问资源，但未满足条件的情况。
    304状态返回时，不包含任何响应的主体部分。其实跟重定向没关系
-307
    临时重定向。跟302差不多

- 400
    表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求
- 401 
    表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息
    另外若之前已进行过一次请求，则表示用户认证失败
    含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询（challenge）用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口
- 403
    表明对请求资源的访问被服务器拒绝了。一般是没有获得授权
- 404
    表示服务器上无法找到请求的资源

- 500
    服务器端在执行请求时发生了错误
- 503
    表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除状况的时间，最后写入 Retry-After首部字段再返回给客户端

# 与HTTP协作的Web服务器
- 在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的W网站，因此在发送HTTP请求时，必须在HOST首部内完整指定主机名或域名的URI

## 代理
    一种有转发功能的应用程序，扮演了服务器和客户端的中间人的角色
    转发时，需要附加Via首部字段以标记出经过的主机信息。
    使用代理服务器的理由有:
- 利用缓存技术减少网络带宽
- 组织内部针对特定网站的访问控制
- 以获取日志为主要目的

### 缓存代理
    代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上。
    当代理再次接收到对相同的资源请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回

### 透明代理
    转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。反之为不透明 

- 网关
    转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理，有时客户端可能都不会察觉，自己的通信目标是一个网关
    跟代理的工作机制比较像。网关能使通信线路上的服务器提供非HTTP协议服务
    利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全
- 隧道
    在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序
    可按要求建立起一条与其它服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信
    隧道本身不会去解析HTTP请求。隧道会在通信双方断开连接时结束

# HTTP首部
## HTTP请求报文
在请求中，HTTP报文由方法，URI，HTTP版本，HTTP首部字段等部分构成

## HTTP响应报文
在响应中，HTTP报文由HTTP版本，状态码（数字和原因短语），HTTP首部字段3部分构成

## HTTP首部字段
### 类型
- 通用首部字段
    请求和响应报文都会使用的首部
- 请求首部字段
    从客户端向服务器发送请求报文时使用的首部。补充了请求的附加内容，客户端信息，响应内容相关优先级等信息
- 响应首部字段
    从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息
- 实体首部字段
    针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息

### HTTP1.1首部字段一览
#### 通用首部字段
- Cache-Control : 控制缓存的行为
    指令的参数是可选的，多个指令之间通过 "," 分隔
    + 缓存请求指令
    
    |       指令      |  参数  |             说明             |
    |-----------------|--------|------------------------------|
    | no-cache        | 无     | 强制向源服务器再次验证       |
    | no-store        | 无     | 不缓存请求或响应任何内容，暗示有机密     |
    | max-age = ?秒   | 必须   | 响应的最大Age值，缓存的时间比参数小就接收              |
    | max-stale 秒    | 可省略 | 接收已过期的响应 ，未指定的参数的话无论过期多久都接收            |
    | min-fresh 秒    | 必需   | 期望在指定时间内的响应仍有效，要求返回至少还未过指定时间的缓存资源 |
    | no-transform    | 无     | 代理不可更改媒体类型         |
    | only-if-cached  | 无     | 仅从缓存获取资源，如果没有响应会返回 504               |
    | cache-extension | -      | 新指令标记                   |
    
    + 缓存响应指令
    
    |       指令       |  参数  |                                             说明                                             |
    |------------------|--------|----------------------------------------------------------------------------------------------|
    | public           | 无     | 可向任意方提供响应的缓存                                                                     |
    | private          | 可省略 | 仅向特定用户返回响应                                                                         |
    | no-cache         | 可省略 | 缓存前必须先确定其有效性，有参数的话表明客户端接收到的该参数的首部字段的响应报文是不能缓存的 |
    | no-store         | 无     | 不缓存请求或响应的任何内容                                                                   |
    | no-transform     | 无     | 代理不可更改媒体类型 ，防止缓存或代理压缩图片等操作                                          |
    | must-revalidate  | 无     | 可缓存但必须再向源服务器进行确认，若无法再次获取有效资源，返回504,该指令会忽略 max-stale     |
    | proxy-revalidate | 无     | 要求中间缓存服务器对缓存的响应有效性再进行确认                                               |
    | max-age = 秒     | 必需   | 响应的最大Age值                                                                              |
    | s-maxage= 秒     | 必需   | 公共缓存服务器响应的最大Age值，狐狸Expires 首部字段及max-age指令的处理                       |
    | cache-extension  | -      | 新指令标记(token),仅对能理解的缓存服务器有意义                                                                          |
- Connection : 逐跳首部，连接的管理
    + 控制不再转发给代理的首部字段，也就是跟下一个服务器说把我这个参数的头给删掉
    + 管理持久连接 HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。
    服务器想断开时，则指定参数为close
    之前的版本默认是非持久，所以客户端要发送参数为 Keep-Alive
- Date : 创建报文的日期时间
- Pragma : 报文指令,1.1之前的历史遗留字段
- Tralier : 报文末端的首部一览，事先说明在报文主体后记录了哪些首部字段。
            该首部字段可应用在HTTP1.1版本分块传输编码时
- Transfer-Encoding : 指定报文主体的传输编码方式,HTTP/1.1的传输编码方式仅对分块传输编码有效
- Upgrade : 升级为其它协议，检测是否可用更高的版本进行通信，可以指定一个完全不同的通信协议
- Via : 代理服务器的相关信息,报文经过代理或网关时，会现在首部字段Via中附加该服务器的信息，然后再进行转发。该字段不仅用于追踪报文的转发，还可以避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。经常和TRACE方法一起使用

- Warning : 错误通知，通常是一些缓存相关的问题的警告

| 警告码 |                警告内容               |                              说明                              |
|--------|---------------------------------------|----------------------------------------------------------------|
|    110 | Response is stale(响应已过期)         | 代理返回已过期的资源                                           |
|    111 | Revalidation failed(再验证失败)       | 代理再验证资源有效性时失败（服务器无法到达等原因）             |
|    112 | Disconnection operation(断开连接操作) | 代理与互联网连接被故意切断                                     |
|    113 | Heuristic expiration(试探性过期)      | 响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下） |
|    199 | Miscellaneous warning(杂项警告)       | 任意内容                                                       |
|    214 | Transformation applied(使用了转换)    | 代理对内容编码或媒体类型等执行了某些处理时                     |
|    299 | Miscellaneous persisent warnin        | 任意的警告内容                                                               |

#### 请求首部字段
- Accept : 用户代理可处理的媒体类型,可以使用 type/subtype 这种形式，一次指定多种媒体类型
            可以使用q= 来表示额外权重，用分号(;)隔开，范围是0~1
- Accept-Charset: 优先的字符集,可一次性指定多哦，也可以指定权重
- Accept-Encoding: 优先的内容编码，可一次性指定多个和权重 gzip compress deflate identity
- Accept-Language : 优先的语言（自然语言）,指定读多个和权重
- Authorization: Web认证信息，接收401之后将该字段加入请求中
- Expect : 期待服务器的特定行为，服务器无法理解的话返回417,HTTP1.1只规定了100-continue
- From : 用户的电子邮箱地址,通常是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式
- Host : 请求资源所在服务器，该字段必须有
- if-Match ： 比较实体标记（ETag)。此时服务器无法使用弱ETag值，服务器比较头的值和资源的ET值，一致的时候才会请求资源
- if-Modified-Since : 比较资源的更新时间，在指定日期后更新了资源的话，服务器会接受请求，否则返回304
- if-None-Match : 比较实体标记，和if-Match 相反
- if-Range : 资源未更新时发送实体Byte的范围请求.
附带条件。告知服务器若指定的if-Range字段值（ETag或时间）和请求资源的ETag值或时间相一致时，则作为范围请求处理。反之，返回全体资源
- if-Unmodified-Since : 比较资源的更新时间（与if-Modified-Since） 相反
- Max-Forwards : 最大传输逐跳数，通过TRACE方法或OPTIONS方法。为0的时候服务器返回响应
- Proxy-Authorization : 代理服务器要求客户端的认证信息
- Range : 实体的字节范围请求
- Referer : 对请求中的URI的原始获取方
告知服务器请求的原始资源的URI
- TE : 传输编码的优先级
- User-Agent : HTTP客户端程序的信息，可能有爬虫作者的电子邮箱或代理服务器的名称

#### 响应首部字段
- Accept_Ranges : 是否接受字节范围请求。
可处理范围请求时指定为bytes,否则为none
- Age : 推算资源创建经过时间
告知源服务器在多久前创建了响应。单位为秒。缓存服务器的话，Age值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应必须添加该字段
- ETag : 资源的匹配信息。
告知客户端的实体标识。一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag的值。另外，当资源更新时，ETag值也需要更新
    + 强ETag值
        不论实体发生多么细微的变化都会改变其值
    + 弱ETag值
        只用于提示资源是否相同。只有资源发生了根本改变，产生差异才会改变tag值
        此时会在字段值最开始处附加W/
- Location : 令客户端重定向至指定URI
            基本上会配合3xx:Redirection的响应使用
- Proxy-Authenticate : 代理服务器对客户端的认证信息
会把由代理服务器所要求的认证信息发送给客户端
- Retry-After : 对再次发起请求的时机要求
要配合 503 Service Unavaliable响应或和 3xx Redirect 响应一起使用
字段值可以指定为具体的日期时间，也可以是创建响应后的秒数
- Server : HTTP服务器的安装信息,包括软件应用名称，还可能由版本号和安装时启用的可选项
- Vary : 代理服务器缓存的管理信息
源服务器会向代理服务器传达关于本地缓存使用方法的命令
从代理服务器接收到源服务器返回包含Vary指定项的响应之后，
若再要进行缓存，仅对请求中含有相同Vary指定首部字段的请求返回缓存
即使对相同资源发起请求，如果Vary指定的首部字段不同，也必须从源服务器重新获取资源。
- WWW-Authenticate : 服务器对客户端的认证信息
用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案(Basic或Digest)和带参数提示的质询(challenge)。
401比如带这个

#### 实体首部字段
- Allow : 资源可支持的HTTP方法,不支持返回405
- Content-Encoding : 实体主体适用的编码方式
告知客户端服务器对实体的主体部分选用的内容编码方式。
内容编码是指在不丢失实体信息的前提下所进行的压缩
- Content-Language : 实体主体的自然语言
- Content-Length ； 实体主体的大小（单位:字节）
对实体主体进行内容编码传输时，不使用该首部字段
- Content-Location : 替代对应资源的URI
报文主体部分相对应的URI。和Location不同，这个首部字段表示的是报文主体返回资源的对应的URI。
- Content-MD5 : 实体主体的报文摘要
目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达
客户端收到报文后会进行检查
这种方法无法检测出恶意篡改和偶发性
- Content-Range : 实体主体的位置范围
- Content-Type : 实体主体的媒体类型
- Expires : 实体主体过期的日期类型
- Last-Modified : 资源的最后修改日期

### 为Cookie服务的首部字段
- Set-Cookie: 开始状态管理所使用的Cookie信息,响应首部字段
    当服务器准备开始管理客户端的状态时，会事先告知各种信息。
    字段值
    + NAME=VALUE : 赋予Cookie的名称和其值（必需项）
    + expires=DATE : Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）
    + path=PATH: 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）
    安全性能不好
    + domain=域名: 作为Cokkie适用对象的域名（若不指定则默认为创建Cookie的服务器的域名）
    因为只检查末尾匹配，实际上不指定比较安全
    + Secure : 仅在HTTPS安全通信时才会发送Cookie。
    + HttpOnly : 加以限制，使Cookie无法被JS访问
    防止跨站脚本攻击
- Cookie: 服务器接收到的Cookie信息,请求首部字段
告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。
### 非HTTP1.1的首部字段
统一归纳在 RFC4299 HTTP Header Field Registrations中

### 端到端的首部
    分在此类别中的首部会转发给请求/响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发

### 逐跳首部
    分在此类中的首部只对单次转发有效，会因通过缓存或代理而不再转发。
    HTTP/1.1和之后的版本中，如果要使用 hop-by-hop 首部，需要提供 Connection 首部字段.
- Connection
- Keep-Alive
- Proxy-Authenticate
- Proxy-Authorization
- Trailer
- TE
- Transfer-Encoding
- Upgrade

### 其它首部字段
- X-Frame-Options 属于响应首部，用于控制网站内容在其它Web网站的Frame标签内的显示问题。其主要目的是为了防止点击劫持攻击
有两个值可以指定
    + DENY: 拒绝
    + SAMEORIGIN: 仅同源域名下的页面匹配时许可
在所有的Web服务器端预先设好X-Frame-Options 字段值是最理想的状态。
- X-XSS-Protection : 属于HTTP响应首部，它是针对跨站脚本攻击(XSS)的一种对策，用于控制浏览器XSS防护机制的开关.
    + 0 : 将XSS过滤设置为无效
    + 1 : 将XSS过滤设置为有效
- DNT： 请求首部，表示拒绝被精准广告追踪
    + 0：同意
    + 1：拒绝
这个字段需要Web服务器对DNT做对应的支持
- PSP: 属于HTTP相应首部，通过P3P（在线隐私偏好平台）技术，可以让Web网站上的
个人隐私变成一种仅供程序可理解的形式，从而达到保护用户隐私的目的
要进行如此设定，需按以下操作步骤进行
    + 创建P3P隐私
    + 创建P3P隐私对照文件后，保存命名为/w3c/p3p.xml
    + 从P3P隐私中新建Compact policies后，输出到HTTP响应中

# 确保Web安全的HTTPS
## HTTP的缺点
- 通信使用明文:内容可能会被窃听
- 不验证通信方的身份，因此可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭遇篡改

## HTTPS
HTTP + 加密 + 认证 + 完整性保护 =HTTPS
HTTPS并非是一种新的应用层协议。只是HTTP通信接口部分用SSL和TSL协议代替了
HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制

# 确认访问用户身份的认证
## HTTP使用的认证方式如下所示
- BASIC认证（基本认证）
- DIGEST认证 (摘要认证)
- SSL 客户端认证
- FormBase认证（基于表单认证）
还有别的略过

### BASIC认证
HHTO1.0定义的认证方式,不好用，一般网站都不用
步骤
- 请求的资源需要BASIC认证时，服务器会随状态码401，返回 WWW-Authenticate首部字段
  的响应。该字段内包含认证的方式（BASIC）以及Request-URI安全域字符串(realm)
- 接收到状态码401的客户端为了通过BASIC认证，需要将用户ID以及密码发送给服务器。
    发送的字符串的内容是由用户ID和密码组成，并经过BASE64编码处理
- 收到包含Authorization请求的服务器，会对认证信息的正确性进行验证。验证通过后，则返回一条包含Request-URI资源的响应。

### DIGEST 认证
为了弥补BASIC认证的弱点，从HTTP/1.1起就有了DIGEST认证。该认证同样适用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码。
步骤
- 服务器返回401,以及WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式所需的临时质询码（随机数。nonce）。
WWW-Authenticate内必须包含 realm 和nonce。客户端就是依靠向服务器回送这两个值
进行认证的。
- 接收到401状态码的客户端
    首部字段Authorizaion内必须包含username, realm, nonce, uri和response的字段信息
    username 是realm限定范围内可进行认证的用户名
    uri是Request-URI的值，但考虑到经代理转发后Request-URI的值可能被修改，
    因此事先会复制一份副本保存在uri内
    response也叫作Request-Digest，存放经过MD5运算后的密码字符串，形成响应码
- 接收到包含首部字段Authorization请求的服务器，会确认认证信息的正确性。认证通过后返回Request-URI资源的响应。
并且在首部字段 Authentication-Info写入一些认证成功的相关信息

安全性也不高，不常用

### SSL客户端认证
借由HTTPS的客户端证书完成认证的方式。凭借客户端证书认证，
服务器可确认访问是否来自已登录的客户端
步骤
- 接收到需要认证资源的请求，服务器会发送 Certificate Request报文，要求客户端提供证书
- 用户选择发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate报文方式发送给服务器
- 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，
    然后开始HTTPS加密通信
一般来说，会和基于表单验证结合，形成双因素认证来使用

### 基于表单认证
并非在HTTP协议中定义的.客户端会向服务器上的Web程序发送登录信息，按登录信息的验证结果认证

### Session管理以及Cookie应用
步骤
- 客户端把用户ID和密码等登录信息放入报文的实体部分
- 服务器发放用以识别用户的SessionID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与SessionID绑定后记录在服务器端。
向客户端返回响应时，会在首部字段Set-Cookie内写入SessionID
- 客户端接收到从服务器端发来的SessionID后，会将其作为Cookie保存在本地。下次发送请求时随之发送

#基于HTTP的功能追加协议
## 消除HTTP瓶颈的SPDY
### 造成HTTP性能瓶颈的原因
- 一条连接上只可发送一个请求
- 请求只能从客户端开始。客户端不可接收除响应以外的指令
- 请求/响应首部未经压缩就发送。首部信息越多越延迟
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。
- 可任意选择数据压缩格式。非强制压缩发送。

### AJAX和Comet等技术能提高易用性，但没改变根本 

### SPDY
在TCP/IP的应用层与传输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY规定通信中使用SSL。
使用SPDY后，HTTP协议获得以下功能
- 多路复用流
通过单一的TCP连接，可以无限制地处理多个HTTP请求。所有请求的处理都在TCP连接上完成，因此TCP的处理效率得到提高。
- 赋予请求优先级
不仅可以无限制地处理并发请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。
- 压缩HTTP首部
压缩HTTP请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了
- 推送功能
支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
- 服务器提示功能
服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已经缓存的情况下，尅避免发送不必要的请求。

要使用的话浏览器和服务器都要做出一定程度上的改动

## 使用浏览器进行全双工通信的WebSocket
客户端发起，一旦确立WebSocket通信连接，不论是服务器还是客户端，任意一方都可以直接向对方发送报文。
主要优点
- 推送功能
支持由服务器向客户端推送数据的推送功能。这样，服务器可以直接发送数据。
- 减少通信量
只要建立起WebSocket 连接，就希望一直保持连接状态。和HTTP相比，不但每次连接时的总开销减少。而且由于WebSocket的首部信息很少，通信量也相应减少了。

为了实现WebSocket通信，在HTTP连接建立之后，需要完成一次"握手"的步骤
- 握手请求
为了实现WebSocket通信，需要用到HTTP的Upgrade首部字段，告知服务器通信协议发生改变，已达到握手目的
Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。
Sec-WebSocket-Protocol 字段内记录使用的子协议
子协议按WebSocket协议标准在连接分开使用时，定义那些连接的名称
- 握手响应
对于之前的请求，返回 101 Switching Protocols的响应。
Sec-WebSocket-Accept的字段值是由握手请求中得Sec-WebSocket-Key的字段值生成的。

成功握手确立WebSocket连接之后，通信时不再使用HTTP的数据帧，而采用WebSocket独立的数据帧。

## 期盼已久的HTTP/2.0
未确定，待补完

## Web服务器管理文件的WebDAV
是一个可对Web服务器上的内容直接进行文件复制，编辑等操作的分布式文件系统。
除了创建，删除文件等基本功能，还具备文件创建者管理，文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。
### 拓展HTTP/1.1的WebDAV
针对服务器上的资源，WebDAV新增加了一些概念
- 集合 Collection : 一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可以实现类似集合的集合这样的叠加。
- 资源 Resource : 把文件或集合称为资源。
- 属性 Property : 定义资源的属性。定义以“名称=值”的格式执行。
- 锁 Lock : 把文件设置为无法编辑的状态。

### 为实现远程文件管理，向HTTP/1.1中追加了以下这些方法。
- PROPFIND : 获取属性
- PROPPATCH : 修改属性
- MKCOL : 创建集合
- COPY : 复制资源及属性
- MOVE : 移动资源
- LOCK : 资源加锁
- UNLOCK : 资源解锁

状态码也拓展了
- 102 Processing : 可正常处理请求，但目前是处理中状态
- 207 Multi-Status : 存在多种状态
- 422 Unprocessible Entity: 格式正确，内容有误
- 423 Locked : 资源已被加锁
- 424 Failed Dependency : 处理与某请求关联的请求失败，因此不再维持依赖关系
- 507 Insufficient storage : 保存空间不足

# 构建Web内容的技术
## HTML
## Web应用
### 与Web服务器以及程序协作的CGI
通用网关接口是指Web服务器在接收到客户端发送过来的请求后转发给程序的一组机制。
在CGI的作用下，程序会对请求内容作出相应的动作，比如创建HTML等动态内容
### Java的Servlet

## 数据发布的格式及语言
### XML
### RSS/Atom
### JSON

# Web的攻击技术
